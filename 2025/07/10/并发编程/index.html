<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>并发编程 | Wizard</title><meta name="keywords" content="面试"><meta name="author" content="Wizard小志"><meta name="copyright" content="Wizard小志"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="并发编程"><meta name="application-name" content="并发编程"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="并发编程"><meta property="og:url" content="https://yanruizhi.github.io/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html"><meta property="og:site_name" content="Wizard"><meta property="og:description" content="一、并发编程并发编程三大特性一、原子性、有序性、可见性1.1 原子性数据库的事务：ACID A：原子性-事务是一个最小的执行的单位，一次事务的多次操作要么都成功，要么都失败。 并发编程的原子性：一个或多个指令在CPU执行过程中不允许中断的。 i++;操作是原子性？ 肯定不是：i++操作一共有三个指令"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp"><meta property="article:author" content="Wizard小志"><meta property="article:tag" content="关键字"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp"><meta name="description" content="一、并发编程并发编程三大特性一、原子性、有序性、可见性1.1 原子性数据库的事务：ACID A：原子性-事务是一个最小的执行的单位，一次事务的多次操作要么都成功，要么都失败。 并发编程的原子性：一个或多个指令在CPU执行过程中不允许中断的。 i++;操作是原子性？ 肯定不是：i++操作一共有三个指令"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://yanruizhi.github.io/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/fontawesome_animation"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: 'https://twikoo-rouge-seven.vercel.app/',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🏠 智能家居小能手"]},
  algolia: {"appId":"10LUYIU2T9","apiKey":"40712f1b5a6970a7823b62e64add494c","indexName":"hexo","hits":{"per_page":10},"languages":{"input_placeholder":"输入关键词后按下回车查找","hits_empty":"找不到您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，用时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Wizard小志","link":"链接: ","source":"来源: Wizard","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Wizard',
  title: '并发编程',
  postAI: '',
  pageFillDescription: '一、并发编程, 并发编程三大特性, 一、原子性、有序性、可见性, 1.1 原子性, 1.2 有序性, 1.3 可见性, 二、synchronized使用, 2.1 synchronized的使用方式, 三、synchronized锁升级, 四、synchronized-ObjectMonitor, 二、ReentrantLock源码, 一、ReentrantLock介绍, 二、ReentrantLock的lock方法源码, 三、ReentrantLock的acquire方法源码, 四、ReentrantLock的tryAcquire方法, 五、ReentrantLock的addWaiter方法, 六、ReentrantLock的acquireQueued, 七、ReentrantLock的unlock方法, 三、ReentrantReadWriteLock读写锁源码, 一、为什么要出现读写锁, 二、读写锁的核心思想, 三、写锁的操作, 3.1 写锁加锁-acquire, 剩下的addWaiter和acquireQueued和ReentrantLock看的一样都是AQS自身提供的方法, 3.2 写锁-释放锁操作, 四、读锁的操作, 4.1 读锁的加锁操作, 4.2 加锁-扔到队列准备阻塞操作, 四、线程池源码, 一、线程池介绍, 二、线程池核心属性认知, 三、execute方法, 四、addWorker添加工作线程, 五、runWorker执行任务, 六、getTask工作线程排队拿任务, 七、processWorkerExit工作线程告辞~, 五、ConcurrentHashMap源码分析（一）, 一、结构介绍, 二、散列算法, 三、初始化数组, 四、添加数据-数组, 五、添加数据-链表, 六、触发扩容, 七、HashMap的扩容, 六、ConcurrentHashMap扩容, 一、tryPreSize方法-初始化数组, 二、tryPreSize方法-扩容标识戳, 三、transfer方法-构建新数组, 四、transfer方法-迁移数据, 五、transfer方法-lastRun机制, 六、helpTransfer方法-协助扩容, 七、JUC并发工具, 一、CountDownLatch应用, 二、CountDownLatch核心源码分析, 2.1 从构造方法查看, 2.2 countDown方法, 2.3 await方法, 三、Semaphore应用, 四、Semaphore核心源码分析, 4.1 有参构造, 4.2 acquire, 4.3 release, 4.4 分析AQS中PROPAGATE类型节点（唯一的难点）, 五、CyclicBarrier应用, 六、CyclicBarrier核心源码分析, 6.1 有参构造, 6.2 await, 八、JUC阻塞队列, 一、ArrayBlockingQueue, 1.1 ArrayBlockingQueue应用, 1.2 存数据源码, 1.3 取数据, 二、LinkedBlockingQueue, 2.1 写操作, 2.2 读操作, 三、PriorityQueue, 3.1 添加操作上移保证结构, 3.2 取数据如何保证二叉堆结构, 四、PriorityBlockingQueue, 4.1 写操作, 4.2 读操作, 九、JUC阻塞队列第二弹, 一、DelayQueue, 1.1 掌握DelayQueue应用, 1.2 分析源码, 二、SynchronousQueue, 2.1 介绍amp应用, 2.1 核心内容, 2.3 生产者和消费者执行套路, 十、ScheduledThreadPoolExecutor, 一、ScheduledThreadPoolExecutor介绍amp应用, 二、ScheduleThreadPoolExecutor底层结构, 2.1 ScheduledFutureTask, 2.2 DelayedWorkQueue, 三、execute方法分析, 四、schedule方法分析, 五、scheduleAtFixedRate和scheduleWithFixedDelay分析, 十一、FutureTask源码, 一、Future介绍, 二、FutureTask使用, 三、FutureTask源码分析, 四、牛批的CompletableFuture, 十二、CompletableFuture应用, 回顾：, 一、CompletableFuture的应用, 二、基于上面阐述做应用, 2.1 小一要回家干法小二去做饭小一看电视等到小二昨晚小一干饭。, 2.2 小一要回家干法小二去炒菜小三去焖饭小一看电视等到小二和小三都做好了小四端菜和饭给小一小一干饭, 十三、CompletableFuture源码分析, 一、runAsync方法源码分析, 1.1 当前异步任务执行流程, 1.2 后续任务的触发方式, 二、thenRun方法源码分析, 三、整体执行流程图, 十四、并发编程总结, 一、锁, 1.1 synchronized（看到Java层面就够了）, 1.2 ReentrantLock, 1.3 ReentrantReadWriteLock, 二、ThreadPoolExecutor, 三、ConcurrentHashMap（1.8）, 四、并发工具, 4.1 CountDownLatch, 4.2 Semaphore, 4.3 CyclicBarrier, 5、阻塞队列, 5.1 ArrayBlockingQueue, 5.2 LinkedBlockingQueue, 5.3 PriorityQueue, 5.4 PriorityBlockingQueue, 5.5 DelayedQueue, 5.6 SynchronousQueue, 6、ScheduleThreadPoolExecutor, 7、CompletableFuture一并发编程并发编程三大特性一原子性有序性可见性原子性数据库的事务原子性事务是一个最小的执行的单位一次事务的多次操作要么都成功要么都失败并发编程的原子性一个或多个指令在执行过程中不允许中断的操作是原子性肯定不是操作一共有三个指令从主内存拉取数据到寄存器在寄存器内部对数据进行将寄存器中的结果甩到主内存中如何保证是原子性的锁使用锁也会有类似的概念也就是在操作的三个指令前先基于成功修改后才可以操作使用和锁时可能会触发将线程挂起的操作而这种操作会触发内核态和用户态的切换从而导致消耗资源方式就相对和锁的效率更高也说不定因为不会触发线程挂起操作线程基于修改数据的方式先获取主内存数据在修改之前先比较数据是否一致如果一致修改主内存数据如果不一致放弃这次修改就是比较和交换而比较和交换是一个原子操作在层面就是类中提供的一个方法这个方法只提供了成功返回失败返回如果需要重试策略自己实现问题只能对一个变量的修改实现原子性存在问题线程修改主内存数据从卡在了获取之后线程修改主内存数据从完成线程修改主内存数据从完成线程执行操作发现主内存是没问题直接修改解决方案加版本号在执行次数过多但是依旧无法实现对数据的修改会一直调度这个线程造成对的性能损耗的实现方式自旋一定次数后如果还不成挂起线程的实现方式当失败后将操作的值存储起来后续一起添加在多核情况下有指令保证只有一个线程在执行当前有序性指令在调度执行时会为了提升执行效率在不影响结果的前提下对指令进行重新排序如果不希望对指定进行重排序怎么办可以对属性追加修饰就不会对当前属性的操作进行指令重排序什么时候指令重排满足原则即可重排序单例模式双重判断申请内存初始化关联是正常顺序如果对指令重排可能会造成申请内存关联初始化在还没有初始化时其他线程来获取数据导致获取到的数据虽然有地址引用但是内部的数据还没初始化都是默认值导致使用时可能出现与预期不符的结果可见性可见性前面说过在处理时需要将主内存数据甩到我的寄存机中再执行指令指向完指令后需要将寄存器数据扔回到主内存中倒是寄存器数据同步到主内存是遵循协议的说人话就是不是每次操作结束就将缓存数据同步到主内存造成多个线程看到的数据不一样每次操作后立即同步数据到主内存触发同步数据到主内存也可以解决可见性问题二使用的使用方式方法代码块类锁和对象锁类锁基础当前类的加锁对象锁基于对象加锁是互斥锁每个线程获取时基于绑定的对象去获取锁锁是基于对象实现的是如何基于对象实现的互斥锁先了解对象再内存中是如何存储的在中查看导入依赖查看对象信息初始化的对象是无锁状态三锁升级在之前一直是重量级锁只要线程获取锁资源失败直接挂起线程用户内核在之前效率贼低再加上推出了效率比快多了导致团队不得不在将做优化锁升级无锁状态匿名偏向状态没有线程拿锁偏向锁状态没有线程的竞争只有一个线程再获取锁资源线程竞争锁资源时发现当前没有线程占用锁资源并且锁是偏向锁使用的方式设置的线程为当前线程获取到锁资源下次当前线程再次获取时只需要判断是偏向锁并且线程是当前线程即可直接获得到锁资源轻量级锁偏向锁出现竞争时会升级到轻量级锁触发偏向锁撤销轻量级锁的状态下线程会基于的方式尝试获取锁资源的次数是基于自适应自旋锁实现的会自动的基于上一次获取锁是否成功来决定这次获取锁资源要多少次重量级锁轻量级锁一段次数后没有拿到锁资源升级为重量级锁其实操作是在重量级锁时执行的重量级锁就是线程拿不到锁就挂起偏向锁是延迟开启的并且在开启偏向锁之后默认不存在无锁状态只存在匿名偏向因为不存在从重量级锁降级到偏向或者是轻量在偏向锁升级到轻量锁时会涉及到偏向锁撤销需要等到一个安全点才可以撤销并发偏向锁撤销比较消耗资源在程序启动时偏向锁有一个延迟开启的操作因为项目启动时会加载文件这里会涉及到操作为了避免启动时涉及到偏向锁撤销导致启动效率变慢所以程序启动时默认不是开启偏向锁的如果在开启偏向锁的情况下查看对象默认对象是匿名偏向编译器优化的结果出现了下列效果锁消除线程在执行一段代码块时发现没有共享数据的操作自动帮你把去掉锁膨胀在一个多次循环的操作中频繁的获取和释放锁资源在编译时可能会优化到循环外部四涉及一般是到达了重量级锁才会涉及到在到达重量级锁之后重量级锁的指针会指向对象抢占锁资源的线程个数调用的线程个数可重入锁标记持有锁的线程的线程双向链表假定的继承人锁释放后被唤醒的线程有可能拿到锁资源挂起线程存放的位置单向链表会在一定的机制下将里的等待线程扔到当前里双向链表偏向锁会降级到无锁状态嘛怎么降会当偏向锁状态下获取当前对象的值会因为对象头空间无法存储导致降级到无锁状态二源码一介绍中提供锁一般就是和锁是互斥锁跟一样如果竞争比较激烈推荐锁效率更高如果几乎没有竞争推荐原因只有锁升级当升级到重量级锁后无法降级到轻量级偏向锁锁的使用相对成本更高是非公平锁是公平非公平锁锁提供的功能更完善可以使用指定等待锁的时间锁还提供了允许线程在获取锁的期间被中断基于对象实现锁基于实现业务代码二的方法源码清楚方法是如何实现让当前线程获取到锁资源什么效果算是拿到了锁资源非公平锁上来先尝试将从修改为如果成功代表获取锁资源如果没有成功调用公平锁调用是个什么鬼是中的一个由修饰的类型变量多个线程会通过的方式修改在并发情况下只会有一个线程成功的修改从如果线程修改失败怎么办如果线程没有拿到锁资源会到的双向链表中排队等待在期间线程可能会挂起的双向链表队列是个啥中的双向链表是基于内部类在维护中包含属性并且在中还有两个属性分别是画一下的核心公平非公平的方法源码公平锁的的方法非公平锁的的方法三的方法源码是一个业务方法里面并没有实际的业务处理都是在调用其他方法核心调用方法尝试获取锁资源非公平公平拿到锁资源返回直接结束方法没有拿到锁资源需要执行后面的方法当没有获取锁资源后会先调用会将没有获取到锁资源的线程封装为对象并且插入到的队列的末尾并且作为继续调用方法查看当前排队的是否在队列的前面如果在前面的尝试获取锁资源如果没在前面尝试将线程挂起阻塞起来四的方法分为公平和非公平两种主要做了两件事如果为尝试获取锁资源如果不为看一下是不是锁重入操作非公平非公平锁实现拿到当前线程拿到的如果说明没有线程占用着当前的锁资源没人占用锁资源我直接抢一波不管有没有线程在排队将当前占用这个互斥锁的线程属性设置为当前线程返回拿锁成功当前说明有线程占用着锁资源判断拿着锁的线程是不是当前线程锁重入将再次锁重入是否超过最大限制抛出将值设置给返回拿锁成功公平锁公平锁实现拿到当前线程拿到的阿巴阿巴判断是否有线程在排队如果有线程排队返回配上前面的那会直接不执行返回最外层的如果没有线程排队直接尝试获取锁资源五的方法在获取锁资源失败后需要将当前线程封装为对象并且插入到队列的末尾将当前线程封装为对象并且插入到队列的末尾将当前线程封装为对象为代表互斥锁是节点如果不为有线程正在排队将当前节点的指定尾节点以的方式将当前节点变为节点之前的的指向当前节点添加的流程为自己指向指向自己前节点指向我如果上述方式操作失败导致加入到末尾失败如果失败就基于的方式添加到队列无论怎样都添加进入拿到如果为说明当前没有在队列中创建一个新的作为并且将和指向一个和上述代码一致六的方法会查看当前排队的是否是的如果是尝试获取锁资源如果不是或者获取锁资源失败那么就尝试将当前的线程挂起在挂起线程前需要确认当前节点的上一个节点的状态必须是小于等于如果为代表是取消的节点不能挂起如果为代表挂起当前线程如果为需要将状态改为之后才能挂起当前线程方法查看当前排队的是否是的如果是尝试获取锁资源如果不是或者获取锁资源失败那么就尝试将当前的线程挂起标识循环走起拿到上一个节点说明当前节点是的竞争锁资源成功失败进来说明拿到锁资源成功将当前节点置位和属性置位帮助快速设置获取锁资源成功不管线程中断如果不是或者获取锁资源失败尝试将线程挂起第一个事情当前节点的上一个节点的状态正常第二个事情挂起线程通过将当前线程挂起确保上一个节点状态是正确的拿到上一个节点的状态如果上一个节点为返回挂起线程如果上一个节点是取消状态循环往前找找到一个状态小于等于的节点将小于等于的节点状态该为七的方法释放锁资源将如果减为了唤醒在队列中排队的一定唤醒离最近的释放锁不分公平和非公平就一个方法真正释放锁资源的方法核心的释放锁资源方法释放锁资源释放干净了如果头节点不为并且头节点的状态不为唤醒排队的线程唤醒线程释放锁成功但是核心的释放锁资源方法获取如果释放锁的线程不是占用锁的线程抛异常是否成功的将锁资源释放利索锁资源释放干净将占用锁资源的属性设置为将赋值返回代表释放干净了唤醒节点拿到头节点状态如果头节点状态小于换为拿到当前节点的如果或者的状态为节点不需要唤醒需要唤醒的从尾部往前找找到状态正常的节点小于等于代表正常状态经过循环的获取如果拿到状态正常的节点并且不为唤醒线程为什么唤醒线程时为啥从尾部往前找而不是从前往后找因为在操作时是先将当前的指针指向前面的节点然后是将赋值给当前最后才是能上一个节点的指针指向当前如果从前往后通过去找可能会丢失某个节点导致这个节点不会被唤醒如果从后往前找肯定可以找到全部的节点三读写锁源码一为什么要出现读写锁因为是互斥锁如果有一个操作是读多写少同时还需要保证线程安全那么使用会导致效率比较低因为多个线程在对同一个数据进行读操作时也不会造成线程安全问题所以出现了锁读读操作是共享的写写操作是互斥的读写操作是互斥的写读操作是互斥的单个线程获取写锁后再次获取读锁可以拿到写读可重入单个线程获取读锁后再次获取写锁拿不到读写不可重入使用方式读写锁写锁读锁拿到读锁拿到写锁二读写锁的核心思想还是基于实现的很多功能的实现和类似还是基于的来确定当前线程是否拿到锁资源表示读锁将的高位作为读锁的标识表示写锁将的低位作为写锁的标识锁重入问题写锁重入怎么玩因为写操作和其他操作是互斥的代表同一时间只有一个线程持有着写锁只要锁重入就对低位即可而且锁重入的限制从原来的变为了变短了读锁重入怎么玩读锁的重入不能仿照写锁的方式因为写锁属于互斥锁同一时间只会有一个线程持有写锁但是读锁是共享锁同一时间会有多个线程持有读锁所以每个获取到读锁的线程记录锁重入的方式都是基于自己的存储锁重入次数读锁重入的时候就不操作了不对每次锁重入还要修改只是记录当前线程锁重入的次数需要基于记录写锁写锁读锁拿不到排队写锁全部释放唤醒读锁读锁再次读锁每个读操作的线程在获取读锁时都需要开辟一个读写锁为了优化这个事情做了两手操作第一个拿到读锁的线程不用记录重入次数在读写锁内有有一个记录重入次数还记录了最后一个拿到读锁的线程的重入次数交给属性标识可以避免频繁的在锁重入时从中获取三写锁的操作写锁加锁尝试获取锁资源看一下能否以的方式将从改成功拿锁成功成功走人不成功执行下面方法将当前没按到锁资源的封装成排到里当前排队的能否竞争锁资源不能挂起线程阻塞因为都是的实现主要看高读低写只拿到表示读锁的高位只拿到表示写锁的低位读写锁的写锁获取流程拿到当前线程拿到拿到了写锁的低位标识要么有读操作拿着锁要么有写操作拿着锁如果代表没有写锁拿不到拜拜如果代表有写锁看一下拿占用写锁是不是当前线程如果不是拿不到拜拜到这说明肯定是写锁并且是当前线程持有判断对低位是否会超过超过抛如果没超过锁重入次数返回拿到锁资源到这说明读写锁也分为公平锁和非公平锁公平看下排队不排队就不抢了走方法有排队的返回没排队的返回非公平直接抢方法实现直接返回以的方式将从修改为要么不让抢要么操作失败返回将当前持有互斥锁的线程设置为自己剩下的和和看的一样都是自身提供的方法写锁释放锁操作读写锁的释放操作跟一致只是需要单独获取低位判断是否为为就释放成功写锁的释放锁只有是读写锁重新实现的方法其他的和一致读写锁的真正释放判断释放锁的线程是不是持有锁的线程不是抛异常对拿着从获取低位的值判断是否为返回将持有互斥锁的线程信息置位将之后的复制给四读锁的操作读锁的加锁操作读锁加锁操作尝试获取锁资源获取到返回没获取到返回前面没拿到锁这边需要排队方法获取当前线程拿到那写锁标识如果代表有写锁如果持有写锁的不是当前线程排队去排队没有写锁获取读锁信息公平锁有人排队返回直接拜拜没人排队返回非公平锁正常的逻辑是非公平直接抢因为是读锁每次抢占只要成功必然成功这就会出现问题写操作无法在读锁的情况抢占资源导致写线程饥饿一致阻塞非公平锁会查看是否是写锁的如果是返回如果不是返回查看读锁是否已经达到了最大限制以的方式对的高位拿到锁资源成功第一个拿到锁资源的线程用存储我是锁重入我就是第一个拿到读锁的线程直接对记录重入的次数不是第一个拿到锁资源的先拿到最后一个线程的重入次数我是第二个拿到读锁的或者发现之前有最后一个来的但是不我将我设置为最后一个获取自己的重入次数并赋值给之前拿过现在如果为赋值给重入次数第一个可能是第一次拿第二个可能是重入操作通过没拿到锁资源也没返回就走这拿现在有互斥锁不是自己拜拜公平有排队的进入逻辑没排队的过非公平的是写不是进入逻辑如果不是过这里代码特别乱因为这里的代码为了处理的内存泄漏问题修改过这个逻辑里不会让你拿到锁做被阻塞前的准备什么都不做获取最后一个拿到读锁资源的拿到我自己的记录重入次数的如果我的次数是绝对不是重入操作将我的中的值移除掉不移除会造成内存泄漏如果我的次数是绝对不是重入操作返回等待阻塞吧超过读锁的最大值了没到这就竞争锁资源跟一模一样加锁扔到队列准备阻塞操作没拿到锁准备挂起将当前线程封装为当前为共享锁并添加到队列的模式获取上一个节点如果我的上一个是尝试再次获取锁资源如果大于等于代表获取锁资源成功唤醒中我后面的要获取读锁的线程模式的能否挂起当前线程需要保证我前面的状态为才能执行后面操作挂起四线程池源码一线程池介绍构建线程的方式为了避免频繁创建和销毁线程造成不必要的性能一般在使用线程时会采用线程池核心线程数设置的方案线程池使用方式线程池的核心线程数如何设置任务可以分为两种密集密集任务有返回结果的任务二线程池核心属性认知就是一个写操作用实现保证了原子性维护这线程池的个核心内容线程池状态高位维护着线程池状态工作线程数量核心线程非核心线程低位维护着工作线程个数工作线程的最大个数拿到线程池状态拿到工作线程个数线程池状态三方法通过方法可以看到线程池处理任务的整体执行流程非空拿到通过获取当前工作线程个数代表是核心线程代表是非核心线程如果添加核心线程成功结束掉如果添加失败重新获取核心线程数已经到了最大值添加时线程池状态变为判断线程池是否是运行状态添加任务到工作队列再次获取的值再次判断线程池状态如果状态不是把任务从工作队列移除走一波拒绝策略线程池状态是判断工作线程数是否是个可以将核心线程设置为所有工作线程都是非核心线程核心线程也可以通过超时被销毁所以如果恰巧核心线程被销毁也会出现当前效果添加空任务的非核心线程去处理工作队列中的任务可能工作队列中的任务存满了没添加进去到这就要添加非核心线程去处理任务执行拒绝策略四添加工作线程阿巴阿巴判断线程池状态判断如果线程池的状态为还要处理工作队列中的任务如果你添加工作线程的方式是任务的非核心线程并且工作队列还有任务判断工作线程个数阿巴阿巴判断工作线程是否已经工作线程最大个数判断判断判断是核心线程么如果是判断是否超过核心线程个数判断判断如果是非核心线程查看是否超过设置的最大线程数对工作线程进行操作成功跳出外层循环执行添加工作线程的业务以方式对多线程并发操作只有会有一个成功重新拿判断线程池状态是否有变化添加工作线程的业务工作线程启动了吗工作线程添加了吗就是工作线程创建工作线程将任务传到中只有你写的线程工厂返回的是这里才会为获取锁资源加锁因为我要在启动这个工作线程时避免线程池状态发生变化加锁重新获取拿到线程池状态判断中的是否已经启动了一般不会启动除非你在线程工厂把他启动了将工作线程存储到中获取工作线程个数判断是否需要修改最大工作线程数记录工作线程添加成功如果添加成功启动工作线程设置标识为如果工作线程启动失败如果添加工作线程失败执行说明可能存放到了的中移除减掉的数值尝试干掉自己五执行任务拿到当前线程对象拿到中存放的将中的任务清空揍是一个标识如果自身携带任务直接执行如果携带的是通过去工作队列获取任务判断线程池状态是否大于等于如果是要中断当前线程中断当前线程前置钩子执行任务后置钩子当前工作执行完一个任务就六工作线程排队拿任务超时阿巴线程池状态判断如果线程池状态为工作队列为空如果线程池状态为对工作线程个数对数量的判断判断核心线程是否允许超时工作线程个数是否大于核心线程数判断工作线程是否超过了最大线程数工作队列为工作线程数有问题必须干掉当前工作线程工作线程是否超过了核心线程如果超时就干掉当前线程对工作线程个数如果是非核心走拉取工作队列任务如果是核心线程走一直阻塞拉取工作队列任务当工作队列没有任务时这时就会被通过阻塞线程当有任务添加到工作线程后这是添加完任务后就会用过唤醒阻塞的线程执行的方法并且在指定时间没拿到任务七工作线程告辞如果是不正常操作需要先对工作线程数如果正常情况就了将当前工作线程完整的任务个数赋值给整个线程池中的任务数干掉当前工作线程线程池是否可以中止线程池状态是否发生变化如果当前线程池状态小于判断线程池中的工作队列是否还有任务并且工作线程是否还在添加非核心空任务的线程处理工作队列中的任务拒绝策略线程池提供的拒绝策略一般不适合你的业务场景时你就自己定义即可抛出异常让提交任务的线程处理这个任务啥也不做任务没了扔掉队列最前面的任务尝试把当前任务添加进去任务处理流程主线程执行添加任务线程池创建工作线程执行任务执行任务再次拉取工作队列任务直到工作队列没有任务阻塞工作线程工作线程阻塞在工作队列主线程执行添加任务到工作队列工作线程被唤醒拿到工作队列中的任务执行执行完毕再次拉取工作队列任务直到工作队列没有任务阻塞工作线程五源码分析一一结构介绍和的存储结构是一致的是线程安全的存储结构关于和的区别和都是想中存储值如果出现一致的将新数据覆盖老数据并且返回老数据如果出现一致的什么都不做返回老数据最只有不存在时才会正常的添加数据二散列算法散列算法是为了让的高位参与到索引位置的计算中从而尽可能的打散数据存放到数组上从而减少冲突中还会将值对进行运算让值一定是一个正数存储数据的核心方法和不能为中是允许为的散列算法就是基于进行运算并且根据散列算法的结果确定当前存储到数组的哪个索引位置散列算法散列算法是为了让的高位参与到索引位置的计算中从而尽可能的打散数据存放到数组上从而减少冲突中还会将值对进行运算让值一定是一个正数因为中数组上的数据的值如果为负数有特殊含义代表当前位置数据在扩容并且数据已经迁移到了新数组代表当前索引位置下是一个红黑树转红黑树有参构造代表当前索引位置已经被占了但是值还没放进去呢方法是如何根据值计算存储的位置数组长度三初始化数组死循环是的数组一堆变量代表当前数组没有初始化初始化数组在时不会创建数组在使用时才会创建是标识数组初始化和扩容的标识信息代表正在初始化代表正在扩容代表没有初始化当前数组没有初始化这个值就代表初始化的长度如果已经初始化了就代表下次扩容的阈值初始化数组操作声明临时存数组临时存判断数组还没初始化呢吧赋值并判断是否小于线程先让出的执行权如果大于等于没人在执行初始化操作以的方式将改为代表当前线程正在执行初始化逻辑判断数组还没初始化呢吧拿到数组的初始化长度创建数组依次给局部变量和成员变量赋值计算下次扩容的阈值将扩容阈值赋值给四添加数据数组数据添加到数组上没有冲突数组长度索引位置位置的数据是的值数组索引位置拿到数组指定索引位置的数据当前索引位置数据为以的方式将数据放到的位置上将封装成了一个对象说明当前位置数据已经被迁移到了新数组帮你扩容快点扩容完我好把数据放到新数组五添加数据链表拿到数组长度索引位置位置的数据是的值到这说明出现了冲突位置有数据尝试往位置下挂数据声明返回结果以桶位置数据作为锁锁住当前桶锁粒度更细再判断一次数据没有变化正常挂链表链表添加操作赋值记录链表中的长度暂时指向数组位置数据拿到当前数据的值和数组位置数据的值比较如果相等判断或者返回尝试覆盖原数据先获取老数据如果是方法进去覆盖值如果是进去不逻辑覆盖值暂存指向下一个节点并且如果说明下面没节点了将当前的值封装为对象并挂在最后一个节点的后面红黑树添加套路省略部分代码如果如果判断是扩容还是转红黑树判断是否需要返回六触发扩容判断是否需要转红黑树或者是扩容数组索引位置数组长度判断不为如果数组长度小于不转红黑树先扩容更希望数据存放在数组上只有数组长度大于等于并且链表长度达到才转为红黑树扩容前的一些准备和业务判断转红黑树操作将单向链表转换为对象双向链表再通过方法转为红黑树中保留着双向链表以及红黑树省略部分代码七的扩容六扩容三种触发方式达到了扩容的阈值一方法初始化数组扩容前操作链表转红黑树插入的长度这个判断是给留的要计算当前数组的长度初始化如果大于最大长度直接将数组长度设置为最大值将长度设置的的次幂是初始化数组长度是给赋值正在初始化数组小于正在扩容代表还没初始化数组大于可能初始化了代表阈值也可能没初始化初始化的长度代表没有正在执行初始化也没有正在执行扩容数组数组长度判断数组是不是还没初始化呢初始化数组和一样的东西在和之间选择最大值作为数组的初始化长度要初始化就直接把设置为代表我要初始化数组创建数组初始化数组赋值给成员变量先设置成阈值将赋值给要么是没有超过阈值要么是超过最大值啥事不做省略部分代码二方法扩容标识戳扩容前操作省略部分初始化代码扩容前操作计算扩容标识戳基于老数组长度计算扩容标识戳因为允许多线程迁移数据这里是一个当前在循环中除了初始化没有额外赋值的前提下这个永远进不来虽然是但是清楚代表正在扩容这里是第二个判断协助扩容线程的标识戳是否一致之一在判断扩容操作是否已经到了最后的检查阶段之一判断扩容线程是否已经达到最大值新数组为说明也已经扩容完毕扩容完毕后才会把置位为线程领取任务的最大节点如果为代表所有老数据迁移任务都没领干净了还没有执行扩容当前线程可能是第一个进来执行扩容的线程基于的方式将从原值改为扩容标识戳左移位一定是的负数可以代表当前正在扩容为什么是低位代表个线程扩容低位为就代表个线程正在并发扩容扩容分为部创建新数组迁移数据当最后一个线程迁移完毕数据后对低位最终结果低位还是需要对整个老数组再次检查数据是否迁移干净开始扩容操作传入老数组计算在二进制表示时前面有多少个前面的操作是基于数组长度等到一个标识方便其他线程参与扩容后面的值是为了保证当前扩容戳左移位之后一定是一个负数三方法构建新数组方法计算步长初始化新数组线程领取迁移数据任务判断迁移是否完成并判断当前线程是否是最后一个完成的查看当前位置数据是否为查看当前位置数据是否为链表迁移数据机制红黑树迁移迁移完数据长度小于等于转回链表扩容操作以第一个进来执行扩容的线程为例创建新数组流程老数组长度扩容的步长如果每个线程迁移的长度基于计算大于就采用计算的值如果小于就用每个线程每次最小迁移长度数据这个操作就是为了充分发挥性能因为迁移数据是密集型操作尽量让并发扩容线程数量不要太大从而造成的性能都消耗在了切换上造成扩容效率降低如果要做优化的推荐将扩容线程数设置为和内核数一致如果新数组没有初始化初始化数组新数组赋值给要么要么数组长度达到最大值将成员变量赋值设置为老数组长度老数组长度步长新数组线程领取任务时的核心属性四方法迁移数据第一步线程领取迁移数据的任务省略部分代码老数组长度步长新数组新数组长度线程领取任务时的核心属性先看领取任务的过程声明节点在老数组迁移数据完成后将赋值上去领任务的核心标识扩容结束了咩扩容的循环领取任务的循环第一个判断是为了迁移下一个索引数据暂时不管说明没有任务可以领取了暂时不管开始领取任务如果成功代表当前线程领取了这个范围数据的迁移第二步判断是否结束以及线程退出扩容并且为空时设置并且为直接移动到下个位置省略部分代码老数组长度步长新数组新数组长度线程领取任务时的核心属性先看领取任务的过程声明节点在老数组迁移数据完成后将赋值上去领任务的核心标识扩容结束了咩扩容的循环领取任务的循环第一个判断是为了迁移下一个索引数据暂时不管说明没有任务可以领取了暂时不管开始领取任务如果成功代表当前线程领取了这个范围数据的迁移迁移最后一段的线程干完活了或者其他线程没有任务可以领取了判断结束了没第一次肯定进不来结束扩容将设置为将迁移完数据的新数组指向指向的老数组将复制为下次扩容的阈值结束到这说明当前线程没有任务可以领取了基于的方式将低位代表当前线程退出扩容操作如果是最后一个还有一个额外的活判断我是否是最后一个完成迁移数据的线程如果不是直接结束如果到这说明我是最后一个结束迁移数据的线程结束表示和领取任务的标识全部设置为设置为老数组长度从头到位再检查一次整个老数组额外分析当前线程完成领取的迁移任务后再次进入循环查看是否有任务可以领取如果变为了代表我没有任务可以领取将设置为没有任务可以领取退出当前扩容操作基于将代表我退出扩容操作成功后还要判断我是不是最后一个退出扩容的线程值是否是扩容标识戳如果不是直接结束如果是最后一个结束迁移的线程将复制为老数组长度重新从末位到头部再次检查一圈如果发现迁移为主的数据为设置放置一个代表当前位置迁移完成是在检查时的逻辑五方法机制就是迁移链表到新数组时的操作省略部分代码老数组长度步长新数组新数组长度线程领取任务时的核心属性先看领取任务的过程声明节点在老数组迁移数据完成后将赋值上去领任务的核心标识扩容结束了咩扩容的循环领取任务的循环第一个判断是为了迁移下一个索引数据暂时不管说明没有任务可以领取了暂时不管开始领取任务如果成功代表当前线程领取了这个范围数据的迁移迁移最后一段的线程干完活了或者其他线程没有任务可以领取了判断结束了没第一次肯定进不来结束扩容将设置为将迁移完数据的新数组指向指向的老数组将复制为下次扩容的阈值结束到这说明当前线程没有任务可以领取了基于的方式将低位代表当前线程退出扩容操作如果是最后一个还有一个额外的活判断我是否是最后一个完成迁移数据的线程如果不是直接结束如果到这说明我是最后一个结束迁移数据的线程结束表示和领取任务的标识全部设置为设置为老数组长度从头到位再检查一次整个老数组额外分析当前线程完成领取的迁移任务后再次进入循环查看是否有任务可以领取如果变为了代表我没有任务可以领取将设置为没有任务可以领取退出当前扩容操作基于将代表我退出扩容操作成功后还要判断我是不是最后一个退出扩容的线程值是否是扩容标识戳如果不是直接结束如果是最后一个结束迁移的线程将复制为老数组长度重新从末位到头部再次检查一圈如果发现迁移为主的数据为设置放置一个代表当前位置迁移完成是在检查时的逻辑迁移数据加锁拿到当前位置数据说明当前节点状态正常不是迁移不是红黑树不是预留与老数组进行运算得到这个计算的结果会决定当前数据在迁移时是放到新数组的位置还有新数组的位置机制提前循环一次链表将节点赋值到对应的高低位如果链表最后面的值没有变化那就不动指针直接复制再次循环时就循环到位置不再继续往下循环这样可以不用每个节点都避免和问题放低位放高位将当前迁移完的桶位置设置上代表数据迁移完毕代表执行下次循环省略红黑树迁移六方法协助扩容协助扩容老数组不为当前节点是新数组不为创建自己的扩容标识戳判断之前赋值的内容是否有变化并且是否小于有一个满足就说明不需要协助扩容了将代表来协助扩容了七并发工具跟着我掌握这些内容首先你要对有一定了解一应用本身就好像一个计数器可以让一个线程或多个线程等待其他线程完成后再执行应用方式巨简单声明有参构造传入的值会赋值给基于实现主线会阻塞在这个位置直到的变为二核心源码分析从构造方法查看的有参构造健壮性校验构建给的赋值方法方法本质就是调用了的释放共享锁操作这里的功能都是提供的只有需要实现的类自己去编写业务唤醒在队列中排队的线程实现的业务用赋值如果中的已经为了那么再次执行跟没执行一样而且只要变为就不会阻塞线程方法方法调用了提供的获取共享锁并且允许中断的方法提欧的获取共享锁并且允许中断的方法操作如果返回的是代表肯定大于实现的为返回否则返回让当前线程进到队列排队去将当前线程封装为并且添加到的队列中再次走上面的如果返回的是的代表为会将当前线程和后面所有排队的线程都唤醒三应用也是常用的并发工具一般用于流控比如有一个公共资源多线程都可以访问时可以用信号量做限制连接池内部的链接对象有限每当有一个线程获取连接对象时对信号量当这个线程归还资源时对信号量如果线程拿资源时发现内部的资源个数为就会被阻塞的隔离策略线程池信号量使用方式巨简单声明信号量能否去拿资源拿资源处理业务归还资源四核心源码分析有参构造有公平和非公平两种竞争资源的方式设置资源个数其实就是信号量的资源个数阿巴阿巴公平公平方式先好看队列中有木有排队的有排队的返回执行去排队那资源数如果资源不够直接返回如果资源够执行修改非公平两个一起阿巴阿巴唤醒在中排队的去竞争资源信号量实现的归还资源拿资源最大值再变为负数改一手分析中类型节点唯一的难点中使用信号量时可能会造成在有资源的情况下后继节点无法被唤醒在中问题被修复修复方式就是追加了节点状态来解决共享锁在释放资源后如果头节点为无法确认真的没有后继节点如果头节点为需要将头节点的状态修改为当最新拿到锁资源的线程查看是否有后继节点并且为共享锁就唤醒排队的线程五应用一般称为栅栏和很像在操作时只能使用一次也就是变为之后就无法继续玩了是可以复用的他的计数器可以归位然后再处理而且可以在计数过程中出现问题后重置当前再次重新操作应用一波声明栅栏打手枪第一位选手到位第一位往死里跑第二位选手到位第二位也往死里跑裁判已经到位六核心源码分析有参构造没有直接使用而是使用简介的使用的的有参健壮性判断是修饰的需要在重置时使用是在执行用来计数的当计数为时先执行这个在唤醒被阻塞的线程线程执行方法会对再判断是否为如果不为需要添加到中的的队列中排队并当前线程如果为证明线程到齐需要执行会先将队列中的全部转移到的队列中并且有后继节点的设置为没有后继节点设置为然后重置和标记等到执行后每个线程都会被唤醒选手到位加锁因为是基于的和方法实现的相当于中使用和别忘了只要挂起会释放锁资源里面就是默认判断之前栅栏加入线程时是否有超时中断等问题如果有设置为其他线程再进来直接凉凉对计数器如果完是代表突破栅栏干活默认如果你用的是个参数的有参构造说明你传入了任务先执行有参的任务设置为完之后不是代表还需要等待其他线程如果没设置超时时间设置了超时时间挂起线程允许中断添加到队列不是队列是里的中的队列挂起当前线程到唤醒所有队列里的线程线程这个方法就是将队列中的节点遍历都扔到的队列中真正唤醒的时机是方法重置计数器重置异常判断八阻塞队列阻塞队列队列先进先出的一个数据结构阻塞基于实现的并且线程的挂起也是通过从最常用也是最简单的一底层是采用数组实现的一个队列因为底层是数据一般被成为有界队列其次阻塞方式是基于实现的常用的存取方法应用存数据操作添加数据到队列如果满了扔异常添加数据到队列如果满了返回添加数据到队列如果满了线程挂起添加数据到队列如果满了线程挂起一段时间取数据操作从队列拿数据拿到返回拿到甩异常从队列拿数据拿到返回拿到也返回从队列拿数据拿到返回没数据一直阻塞从队列拿数据拿到返回没数据阻塞时间因为底层使用数组必须要指定数组的长度作为队列的长度存数据操作添加数据到队列如果满了扔异常添加数据到队列如果满了返回添加数据到队列如果满了线程挂起添加数据到队列如果满了线程挂起一段时间取数据操作从队列拿数据拿到返回拿到甩异常从队列拿数据拿到返回拿到也返回从队列拿数据拿到返回没数据一直阻塞从队列拿数据拿到返回没数据阻塞时间存数据源码添加时先判断队列满了没满了就返回添加时先判断队列满了没满了先阻塞时间自动唤醒还是满的也返回添加时先判断队列满了没满了就阻塞阻塞到被唤醒或者被中断存数据非空校验互斥锁如果数组中的数据已经达到了数组的长度没地儿了队列满了还有位置存放数据到数组中拿到数组数组放进去把指针指针是否已经到了最后一个位置归位到位置归位到位置数据条数唤醒在阻塞的取数据线程方法方法可以阻塞一段时间添加时先判断队列满了没满了就返回添加时先判断队列满了没满了先阻塞时间自动唤醒还是满的也返回添加时先判断队列满了没满了就阻塞阻塞到被唤醒或者被中断取数据阿巴阿巴取数据代表没数据就返回有数据走从数组中那数据取数据将取完的位置置位指针如果到头归位数据条数唤醒队列满的时候阻塞住的写线程挂起线程需要被唤醒挂起线程到时间自动唤醒或者被手动唤醒二底层基于链表实现的会将每个元素封装为有当前值还有一个指针一般成为无界队列本质就是一个用封装的单向链表内部提供了读锁和写锁读写不互斥而且记录数据条数的属性是原子类核心属性阻塞队列元素会被封装为指定队列的长度如果不传值默认为记录数据条数读锁写锁写操作写操作非空拿到记录当前数据条数如果达到了最大值数据满了声明将当前数据封装为添加写锁再次拿到条数判断如果还有空间存数据数据放进来拿到再自增添加完数据之后长度依然小于最大长度唤醒可能阻塞的写线程读写不互斥可能前面在执行时队列是满的但是读操作依然在进行说明添加数据之前队列是空的唤醒可能阻塞的读线程返回插入数据到链表读操作为没数据拜拜读锁如果队列有数据说明还有数据唤醒读线程到这说明还有位置呢唤醒写线程三这个就是一个普通的队列不是阻塞的因为和都和有关系很类似先把搞定后续再看其他的优先级阻塞队列效果更佳才是真正而定无界队列底层是数组实现会扩容实现优先级的方式是基于二叉堆实现的二叉堆二叉堆是一颗完整的二叉树任意一个节点大于父节点或者小于父节点因为这个二叉堆是实现优先级队列的原理那么队列或有添加和获取的操作这种操作会影响二叉堆的结构查看队列的添加和获取操作如何保证结构添加操作上移保证结构优先级队列添加操作确定如何保证小顶堆结构是数组数据条数大于等于数组长度后需要扩容数据多一条如果说明添加的是第一个数据不是第一个数据上移保证结构让当前节点和父节点比较如果当前节点比较小就上移取数据如何保证二叉堆结构取堆顶数据没有数据返回最后一个数据的索引需要全都的数据取出最后一个数据将最后一个数据置位下移保证安全堆顶数据下移知道数据可以存放的位置然后替换即可找到左子四这个阻塞的优先级队列的实现跟基本一模一样只是基于锁实现的多线程操作安全并且线程可以挂起阻塞的操作底层基于数组并且可以扩容不会基于挂起线程读会阻塞写操作因为底层基于数组并且可以扩容所以写操作的和的方式不会基于挂起线程并且是多线程基于的方式争抢扩容的标识所有添加都走着没有挂起的方式扩容允许多线程并发扩容一会看添加数据到二叉堆唤醒读线程跟一样的上移操作尝试扩容允许多线程并发扩容的不是协助扩容但是只有一个线程会成功基于的方式避免并发问题线程将从改为得到了扩容的权利可以创建新数组计算新数组长度判断长度是否超过界限创建新数组如果是说明当前线程没有执行扩容操作让出时间片尽量让扩容的线程先走完扩容操作扩容结束读操作的读操作是允许使用挂起的因为二叉堆可能没有数据没有数据就挂起呗基于锁保证安全拿到堆顶数据保证结构下移九阻塞队列第二弹一在学习的原理之前先掌握应用如果需要掌握源码的话需要对有一定掌握也就是二叉堆掌握应用是无界队列延迟的操作可以向延迟队列中追加任务这个任务需要指定延迟时间只有延迟时间到了才可以将任务从队列中获取出来任务可以指定延迟时间所以需要任务满足一定的需求发现中的任务需要实现接口重写和方法任务什么时候可以出队列存放任务到队列时放在二叉堆的哪个位置执行时间单位毫秒任务名称传入延迟时间任务可以出队列的核心方法通过这个方法来比较将任务存放到二叉堆的指定位置基于执行时间比较测试效果分析源码首先想掌握延迟队列的源码信息你需要先掌握优先级队列这个优先级队列是基于二叉堆二叉堆跟二叉树结构很像二叉堆就是满二叉树优先级队列是基于数组实现的在队列内部会对每个节点做排序二叉堆存放数据的顺序是固定的并且没插入一个数据会基于上移操作保证小顶堆的结构如果取出数据要涉及到下移来保证小顶堆结构延迟队列就是基于优先级队列实现的看延迟队列的添加任务方法因为是无界队列空间不够会扩容生产者不需要挂起线程空间肯定可以存放下当前的任务节点只需要查看即可其他的方法也都是调用的延迟队列就这么一个添加任务的方法调用优先级队列添加任务拿到第一个数据看看我是不是第一个如果是第一个可能有消费者挂起了唤醒一波一会说啊挂起线程唤醒线程返回这个是优先级队列的添加延迟队列是基于优先级队列实现的功能空间不够扩容数组放第一个数据不需要上移不是一个数据判断是否需要上移数据怎么从延迟队列拿出来的浅尝的消费者浅尝一下拿数据如果有数据并且延迟时间已经到了返回否则啥也不干拿到堆顶数据如果没数据或者数据的延迟时间没到返回如果有数据并且时间到了基于优先级队列把任务取出来浅尝一会的尝一小会尝时间纳秒判断这里加锁允许中断拿堆顶没数据判断等多久时间没了告辞时间还有等一小会必然有数据取出堆顶数据的剩余时间如果时间已经到位了直接调用优先级队列把数据取出来再次判断等待时间不等告辞将临时变量置位如果剩余的等待时间小于任务的延迟时间肯定拿不到数据的等着玩反正拿不到我等待的时间内必然可以拿到数据并且没有将当前线程置位说明我是第一个在这等待数据的线程当前线程先挂起挂起任务剩余的延迟时间会释放锁重新计算剩余的等待时间将置位如果为并且堆顶有数据执行唤醒操作而方法会调用一致阻塞直到拿到数据与的区别是会计算剩余额的阻塞时间不会首先知道了如何用代码实现首先节点就是任务必须实现接口重写任务出队的时间以及任务的排序方式入队入队只有一个方法就是因为是无界队列所以生产者是不需要阻塞的出队直接拿堆顶数据堆顶的延迟时间到了直接返回任务如果没到时间返回直接拿堆顶数据如果为或者阻塞时间已经到了直接告辞如果不为并且延迟时间到了返回数据如果数据时间没到查看阻塞剩余的时间到了么到了直接返回如果数据的延迟时间没到如果阻塞时间小于延迟时间或者已经有了直接等待阻塞时间等待被唤醒即可当前阻塞时间大于等于延迟时间并且为这是就阻塞延迟时间即可二介绍应用和其他阻塞队列有点区别但是也是阻塞的并不存储数据队列的长度是一个生产者扔数据到后必须等待消费者拿走这个数据才可以跟很像是两个线程交换数据是传递数据不是交换应用的方向是线程间的通讯可以使用使用的方法拿着数据到了如果恰巧有消费者在等待拿数据配对成功着数据到了可以等一会如果期间有消费者来了配对成功着数据到了死等直到消费者来了或者被中断了你懂得浅尝一下核心内容首先想要掌握必须了解因为无论是消费者还是生产者都用到了中的方法生产者调用方法需要传递一个参数也就是数据消费者调用方法第一个参数传递为代表获取数据有两个实现分别对应了的公平操作和不公平操作代表公平处理方式代表不公平处理方式查看内部的实现查看核心属性这个是中的每一个节点如果执行了方法时需要挂起线程而挂起的就是这个线程生产者消费者无参构造会先初始化一个作为和的指向并且这个不包含线程信息就一个伪的头结点生产者和消费者执行套路生产者执行方法时会传递值传递的为浅等传递的是指定数值设置为消费者执行方法时第一个参数会设置为浅等方法与生产者一致分析的方法消费者和生产者都会调用这个房声明判断当前操作的是消费者还是生产者生消拿到头尾节点健壮性判断如果头和尾相等在当前的单向链表中要么都存放生产者要么都存放消费者所以第二个判断是如果队列中有查看我当前的是否和队列中的一致一致挂上去拿到避免并发出现了并发操作重新执行循环如果尾节点的不为有并发情况直接操作将的节点设置为节点重新执行循环进来之后没有立即配对那就直接告辞把当前的初始化将的指向的当前将指向当前等挂起线程直到被唤醒拿到指定的数据拿到的数据和当前一致当前节点取消了清除当前节点告辞判断是否还在队列中将当前节点设置为新的我拿到数据了设置为当前节点对象线程置位返回数据如果逻辑到这需要跟队列中的做配对拿到的并发问题重新循环拿到中的数据队列是消费者队列是生产者出现并发问题装车了取出的数据竟然是节点本身代表节点被取消开始交换数据将当前方法传入数据替换到的如果操作失败并发问题配对失败重新替换节点重新循环操作成功也要替换唤醒队列中的的节点的线程操作成功返回数据十一介绍应用是的一个子类在线程池的基础上实现了延迟执行任务以及周期性执行任务的功能最早提供的是类执行定时任务串行的不靠谱会影响到其他的任务执行在不采用第三方框架时需要执行定时任务是比较好的选择就是在线程池的基础上实现的定时执行任务的功能提供了比较常用的四种方法执行任务不说跟普通线程池执行没区别可以指定延迟时间一次性执行任务可以让任务在固定的周期下执行任务的处理时间不影响下次执行时间如果任务的执行时间超过了设置的延迟时间按照时间最长的计算可以让任务在固定的周期下执行任务的处理时间影响下次执行时间应用效果如果实际开发应用需要使用到定人任务更推荐一些开源你的框架比如因为表达式对时间的控制更加方便二底层结构两个核心内容首先看到了核心内容间接的实现了接口让任务可以放到延迟队列中并且基于二叉堆做排序即将执行的时间越短就往堆顶扔查看核心内容就是计数器每个任务进来时都会有一个全局唯一的序号如果任务的执行时间一模一样比对任务执行的时间单位是纳秒表示一次性执行的任务表示使用的是表示使用的是周期性实行任务时引用具体任务方便后面重新扔到阻塞队列有参构造时使用当前有参重载封装任务时使用当前有参重载封装任务不考虑这个有返回结果实现接口重写的方法执行的时间实现接口重写的方法比较的方式放在二叉堆内部判断是否是周期执行省略部分代码阿巴阿巴三方法分析这个方法是白给的查看即可四方法分析封装任务放延迟队列创建线程准备执行将传入的任务和延迟执行的时间封装分析定时任务线程的延迟一段时间执行一次任务非空判断封装任务将普通的封住为方法默认情况下什么都没做就是返回了方法是线程池给你提供的扩展方法可以在这个位置修改任务需要执行的具体细节延迟执行查看查看方法重载返回当前任务要执行的系统时间判断时间是否小于如果小于正常计算执行的时间如果大于可能出现超过的取值范围问题做额外处理将任务封装为任务要执行的系统时间任务是否是周期性执行基于计算序列化提供的一个扩展方法可以在这个位置细粒度的修改任务执行的细节执行延迟任务分析定时任务线程的延迟一段时间执行一次任务非空判断封装任务将普通的封住为方法默认情况下什么都没做就是返回了方法是线程池给你提供的扩展方法可以在这个位置修改任务需要执行的具体细节延迟执行延迟执行查看线程池是不是已经不是状态如果是拒绝策略到这说明线程池状态是调用阻塞队列将任务添加进去将任务扔到了延迟队列中二叉堆在添加任务到延迟队列的数组时会记录当前任务所在的索引位置方便取消任务时从数组中移除方便取消任务判断线程池是否不是状态如果不是就根据策略决定任务是否执行如果任务不需要执行了调用方法将任务从延迟队列移除并且在内部还会取消任务线程池状态没毛病任务是需要执行的如果任务添加到了阻塞队列中忽然线程池不是状态那么此时这个任务是否执行代表是周期性执行的任务代表是一次性的延迟任务默认情况下如果任务扔到了延迟队列中有两个策略如果任务是周期性执行的默认为如果任务是一次性的延迟任务默认为判断当前任务到底执行不执行重新拿到线程池的如果线程池是返回如果线程池状态是那么就配合策略返回准备执行任务获取线程池中的工作线程个数如果工作线程个数小于核心线程数创建核心线程一致在阻塞队列的位置等待拿任务执行如果工作线程数不小于核心线程但是值为创建非核心线程执行任务创建非核心线程处理阻塞队列任务而且只要阻塞队列没有任务了当前线程立即销毁查看任务放到延迟队列后是如何被工作线程取出来执行的执行方法会创建一个工作线程工作线程在创建成功后会执行方法在方法执行后会调用的方法最终执行了方法在方法中会在阻塞队列的位置执行方法一直阻塞拿任务拿到任务后就返回然后执行所以需要查看的就是延迟队列的方法套路和之前讲的没有区别在拿到任务后会执行任务也就是执行任务的方法执行任务获取任务是否是周期执行周期执行一次的延迟执行再次判断线程池状态是否不是如果不是并且情况也不允许执行或者是状态取消任务当前任务是一次性的延迟执行执行任务具体的方法执行完没了后面是周期执行省略部分代码五和分析在执行方法的初期封装任务时会将设置为正数代表固定周期执行表会将设置为负数代表在执行任务完毕后再计算下次执行的时间固定周期执行任务如果任务的执行时间超过周期任务执行完立即执行下一次任务具体任务第一次执行的时间周期执行时间时间单位阿巴阿巴如果传递的周期小于等于直接抛异常扩展将任务设置给属性方便后期重新扔到延迟队列嗯哼固定周期执行任务会在任务执行完毕后再计算下次执行的时间最终两个方法都会调用方法区将任务扔到阻塞队列并尝试是否需要构建工作线程从而执行任务工作线程会监听延迟队列拿到任务后会调用任务的方法查看和可确定任务是周期执行线程池状态对不一次性的延迟执行到这先执行任务设置下一次任务的运行时间计算任务下次执行时间是任务执行的时间而这里是的上次的执行时间拿到当前任务的直接拿上次执行的时间添加上周期时间来计算下次执行的时间任务执行完拿当前系统时间计算下次执行的时间点重新将任务扔到延迟队列中线程池状态的判断将任务扔到了延迟队列中扔到延迟队列后再次判断线程池状态是否需要取消任务需要创建线程不同步异步阻塞非阻塞同步做了同步操作后被调用者不会主动通知我结果我需要主动查看结果异步做了异步操作后被调用者会主动通知我结果是什么阻塞调用功能后不能做其他事情非阻塞调用功能后可以做其他事情同步阻塞执行烧水功能时我不能做其他事情并且烧水功能执行完后不会主动通知我同步非阻塞执行烧水功能时我可以做其他事情但是烧水功能执行完后不会主动通知我异步阻塞执行烧水功能时我不能做其他事情并且烧水功能执行完后会主动通知我这个操作没有异步非阻塞执行烧水功能时我可以做其他事情并且烧水功能执行完后会主动通知我十一源码一介绍是个什么鬼创建线程的方式一般常用的是如果需要当前处理的任务有返回结果的话需要使用运行需要配合是一个接口一般会使用实现类去接收任务的返回结果存在一些问题的同步非阻塞执行的任务他不会主动通知你返回结果是什么二使用是你要执行的任务是存放任务返回结果的位置任务执行线程启动了线程处理任务三源码分析要分析首先需要查看一下他的核心属性任务正常执行返回结果是正常的结果任务正常执行但是返回结果是异常任务直接被取消的流程代表当前任务的状态任务的初始化状态的结果正常结果异常结果正在封装给当前的任务正常结束执行任务时发生了异常任务被取消了线程的中断状态被设置为了现在还在运行线程被中断了当前要执行的任务存放任务返回结果的属性也就是需要获取的结果执行任务的线程单向链表存放通过方法挂起等待的线程后如何执行的方法其实是通过方法执行的方法方法的执行流程最终会执行的方法保证任务的状态是才可以运行基于的方式将当前线程设置为准备执行任务要执行任务任务不为并且任务的状态还处于放返回结果任务执行是否为正常结束运行方法拿到返回结果封装到中正常返回设置为结果为异常返回设置为设置异常信息正常执行结束设置返回结果将执行任务的设置空拿到状态中断要做一些后续处理设置返回结果首先要将任务状态从设置为将返回结果设置给将状态修改为代表正常技术一会再说你猜猜方法获取返回结果到挂起的位置拿状态满足找个状态就代表现在可能还没有返回结果尝试挂起线程等待拿结果线程要等待任务执行结束等待任务执行的状态变为大于状态计算如果是就是如果是那就追加当前系统时间构建死循环找个的线程是否中断了将当前节点从中移除并且抛出中断异常拿到现在任务的状态判断任务是否已经执行结束了如果设置过直接移除的线程返回当前任务的状态如果任务的状态处于的持续时间非常短只需要做一手现成的让步即可现在线程的状态是方法可能还没执行完呢准备挂起线程封装存放当前线程如果还没有排在中现在就排进来头插法的效果挂起线程的方式计算挂起时间挂起的时间是否小于等于移除中的当前返回任务状态正常指定挂起时间即可线程挂起挂起线程的方式线程挂起后如果任务执行完毕由唤醒线程任务状态已经变为了做一些后续处理拿到第一个节点后直接用的方式将其设置为基于拿到线程信息线程不为将的设置为唤醒这个线程往后遍历接着唤醒指向的扩展方法没任何实现你可以自己实现任务处理完了可以拜拜了拿到返回结果的处理任务结束拿到结果判断是正常返回结束返回结果任务状态是大于取消甩异常扔异常正常返回异常返回取消任务中断任务四牛批的存在的问题问题获取线程执行的结果前主线程需要通过方法一直阻塞等待子线程执行完方法才可以拿到返回结果问题如果不通过去挂起线程通过循环不停的判断任务的执行状态是否结束结束后再拿结果如果任务长时间没执行完毕会一直调度查看任务状态的方法会浪费资源是一个同步非阻塞处理任务的方式需要一个异步非阻塞处理任务的方式在一定程度上就提供了各种异步非阻塞的处理方案并且提供响应式编程代码编写上效果更佳更漂亮是再次又研发也是实现了接口实现的功能可以不使用直接使用即可提供非常丰富的函数去执行各种异步操作十二应用回顾上次课玩的应用起来特别简单他是同步非阻塞会配合执行有返回结果的任务如果需要拿到返回结果需要执行方法获取最终结果因为无法实现异步非阻塞中有个可以实现异步非阻塞的效果再带有返回结果的线程执行完毕后提供一个回调一的应用最重要的就是解决了异步回调的问题就是执行一个异步任务异步任务可以有返回结果也可以没有返回结果提供了两个最基本运行的基本方法函数式编程中三个最核心的接口生产者没有入参但是有返回结果消费者有入参但是没有返回结果函数有入参并且有返回结果异步执行任务有返回结果异步执行任务没有返回结果在不指定线程池的前提下这两个异步任务都是交给去执行的而内部是守护线程守护线程在主线程结束后就不干活了但是只是用这两个方法无法实现异步回调的如果需要在当前任务执行完毕后拿着返回结果或者不拿返回结果继续去执行后续任务操作的话需要基于其他方法去实现这里的方法有个特点都是在前置任务结果后再执行当前任务所以后续看的任务都有一个特点大部分方法一共有三种方法重载不带带带还可以传入线程池的套路等待前一个任务处理结束后拿着前置任务的返回结果再做处理并且返回当前结果线程池跟上面的套路一致但是再执行后续任务时采用全新的线程执行等待前一个任务处理结束后拿着前置任务的返回结果再做处理当然处理没有返回结果线程池跟上面的套路一致但是再执行后续任务时采用全新的线程执行等待前一个任务处理结束后再做处理不接收前置任务结果也不返回结果线程池跟上面的套路一致但是再执行后续任务时采用全新的线程执行其次还有可以执行相对复杂的处理在前一个任务执行的同时执行后续任务等待前置任务和后置任务都搞定之后再执行最终任务可以让任务和任务一起执行等待任务和任务全部搞定获取前两个任务的结果执行最终处理最终处理也可以返回结果线程池跟上面的套路一致但是再执行后续任务时采用全新的线程执行让前置任务和后续任务同时执行都执行完毕后拿到两个任务的结果再做后续处理但是没有返回结果线程池跟上面的套路一致但是再执行后续任务时采用全新的线程执行让前置任务和后续任务同时执行都执行完毕后再做后续处理线程池跟上面的套路一致但是再执行后续任务时采用全新的线程执行后面还提供了可以让两个任务一起执行但是有一个任务结束有返回结果后就做最终处理前面两个任务同时执行有一个任务执行完获取返回结果做最终处理再返回结果前面两个任务同时执行有一个任务执行完获取返回结果做最终处理前面两个任务同时执行有一个任务执行完做最终处理的不说了后面还提供了等到前置任务处理完再做后续处理后续处理返回的结果为连接两个任务前置处理完执行后续后续可以拿到前置任务的结果并且做处理最终返回的是用其实就足够了最后还有处理异常的各种姿势只有当前这个异常处理方法可以获取到前面任务的异常信息有异常才执行当前任务不存在的操作可以拿到上一个任务的返回结果和异常但是当前处理没有返回结果无法影响最终让任务的结果内容这个带有操作可以拿到上一个任务的返回结果和异常同时当前处理可以返回内容二基于上面阐述做应用小一要回家干法小二去做饭小一看电视等到小二昨晚小一干饭小连回家干饭小严做饭锅包肉小连看电视小连干饭小一要回家干法小二去炒菜小三去焖饭小一看电视等到小二和小三都做好了小四端菜和饭给小一小一干饭小连回家干饭小严去炒菜锅包肉小李去焖饭大米饭小陈端饭菜好了小连看电视小连干饭十三源码分析异步回调一方法源码分析基于当前这个最简单的方法来分析是如何执行异步任务的以及如何触发后续任务执行当前异步任务执行流程异步执行任务非空判断声明当前任务的对象在看时任务执行和后续任务的触发是两个操作的这个他的目的是为了触发后续任务的执行将任务和封装到一起作为的对象将交给线程池执行封装任务和的对象存储当前的任务以及声明两个变量一个存储一个存储具体任务非空判断的同时将成员变量做临时存储当前任务是否已经有返回结果任务还没有执行线程池执行异步任务当然是任务没有返回结果的所以这里直接封装为一个表示的标识为的结果是如果异常结束将出现的异常封装到返回结果中执行后续任务后续任务的触发方式当前任务执行完毕触发后续任务当前任务的栈顶拿到栈顶数据栈结构中有后续需要处理的任务进到循环中每次循环之后的指针都会后移栈顶换人啦执行栈顶的任务问题发现的后续任务是基于栈结构存储的但是在测试的代码中执行的顺序没有按照栈结构的方式去执行不保证后续任务的执行顺序从上面的源码分析发现不会出现栈结构完全倒序的情况二方法源码分析后续任务的触发方式有两种一种是基于前继任务执行完毕执行方法触发另一种是后续任务在压栈之前和之后会尝试执行后续任务只要前继任务执行结束的快后续任务就可以直接执行不需要前继任务的触发追加任务到栈结构的逻辑线程池执行器如果是异步调用会传递使用的线程池如果是普通的不会传递线程池为阿巴阿巴当前任务的如果传递了线程池代表异步执行直接走代码块中的内容如果没有传递线程池同步执行需要先执行前继任务还没执行完呢那就准备压栈将线程池后续任务前继任务后续具体任务将封装好的直接到的栈结构中不确保对象一定会被压到栈结构中在这个位置可能会出现前继任务已经执行完毕导致无法压到栈顶尝试执行当前的后续任务当前方法的作用尝试执行任务前继任务后续具体任务现在是只看第二个判断如果前继任务没有执行完毕直接省略部分代码压栈方法不为是前继任务的结果只有前继任务还没有执行完毕时才能将当前的对象压到栈结构中后续任务的执行以及之前将后续任务封装的对象之前封装后继任务调用的有参构造尝试执行任务后续任务前继任务后续具体任务存储后续任务存储前继任务尝试执行后续任务的位置尝试执行后续任务的方法判断前继任务执行完了么如果执行完了直接走后面执行后续任务如果前继任务没执行完返回到这说明前继任务已经执行结束了要执行后续任务但是要先判断后续任务执行了么后续任务还木有执行如果前继任务是异常结束后续任务就不需要执行了正常封装异常信息前继任务正常结束尝试之后后续任务如果代表异步执行如果嵌套执行同步执行异步执行完毕返回需要同步执行正常封装结果异常封装结果执行任务拿到线程池判断当前任务标记是否执行线程池为代表同步执行直接返回异步执行使用线程池执行即可三整体执行流程图十四并发编程总结一锁看到层面就够了对象锁和类锁到底是使用普通出来的对象作为锁还是对象作为锁对象锁多个对象去操作无法实现互斥的类锁无论怎么使用能保证一个内是互斥的原理对象头是基于对象作为锁的锁信息全部都放在了对象的对象头中的中其中线程竞争锁之前肯定需要先查看当前锁的标记位以不同的方式来竞争锁资源锁升级初始化状态的对象的锁信息有两种情况无锁无锁状态当前状态没有开启偏向锁匿名偏向当前状态开启了偏向锁没有偏向任何线程偏向锁只有一个线程来拿锁资源没有竞争轻量级锁以的方式去竞争锁资源不会让线程挂起自适应自旋锁重量级锁直接采用指向的以传统的方式去竞争锁资源偏向锁的重入是如何实现的其实偏向锁时也用到了只不过内部不会存储信息等等在偏向锁重入时每次都会压栈一个从而实现偏向锁重入轻量级锁的是如何实现的在重量级锁中实现的基于方法采用和后期更推荐使用谁后期肯定是使用因为底层更利于后期版本的优化而再怎么玩也是基于层面的锁锁消除层面在编译时如果发展加锁的位置不存在任何的共享资源操作或者是引发线程安全问题的那么去掉竞争和释放锁资源的操作锁膨胀队列状态位就是一个下的基础类大量下的并发工具都是基于实现的状态位修饰修改的类型数值队列双向链表每个节点是一个公平锁和非公平锁非公平锁直接修改如果失败执行公平锁执行执行在发现为时非公平锁直接修改公平锁查看队列中是否有排队的如果有查看的是不是当前线程然后再决定是否修改为什么唤醒时要从后往前遍历找到离最近的在执行方法时先将当前的指向前一个节点再将指向当前节点此时上一个节点的还有没有指向当前节点如果存在并发问题会导致遍历时丢失节点读写锁实现实现原理还是基于实现的将的高位作为读锁的信息低位作为写锁的信息读锁是共享锁写锁是互斥锁如何避免写锁饥饿的读锁获取锁资源时判断当前在中排队的是否是写锁资源如果是写锁读锁会直接在中排队读锁重入如何实现读锁可能会有多个线程同时持有如果不清楚每个线程重入的次数无法确定读锁资源是否释放干净就基于来记录当前线程读锁重入的次数当然同时也要对的高位进行修改读锁重入的优化第一个持有读锁的线程无需将重入次数设置到中直接使用读写锁内部提供的来记录当前线程采用来记录读锁重入的次数最后一个来竞争读锁资源的线程不包含第一个采用来记录锁重入次数也会在中存储一份但是如果当前线程再次重入不需要从中获取而是直接修改即可二线程池的个核心参数不会的出门左转线程池的拒绝策略线程池自带四种如何可以满足业务需求直接用即可如果不满足可以自行实现接口重写功能线程池的状态是过渡状态可以从和状态转换过来其实到了工作线程已经没了工作队列的任务也处理完了就差执行一个方法转换到状态线程池的属性高位存储线程池状态低位存储工作线程个数线程池的执行流程不会的出门右转为什么线程池要添加非核心并且没有任务的工作线程当前工作线程个数为但是工作队列中有任务此时就需要添加一个非核心并且空任务的工作线程去处理阻塞队列中的任务中的锁是干嘛的中基于实现了一个非可重入锁为了避免中断线程时还没有初始化完成导致出现问题如何在线程池之前任务前后做额外处理线程池提供了两个勾子函数三在中如何实现线程安全阿巴阿巴的散列算法阿巴阿巴的数组长度为何是的次幂阿巴阿巴如何实现并发扩容的扩容线程数中的如何实现在记录中元素的个数因为在高并发情况下性能较低所以中采用了的实现方式其实就是将的源码复制过来改了一改并且在方法中还会有扩容的判断红黑树什么情况会转换为链表扩容时或者删除红黑树数据长度小于等于时都有可能将红黑树转为链表在有线程写红黑树时读操作怎么办链表在扩容为红黑树的同时会保留双向链表和红黑树此时会查询双向链表不会查询红黑树的机制是什么阿巴阿巴四并发工具实现原理基于实现的初始化时给定一个的值每次线程执行方法时对如果线程在执行方法时此时线程挂起此时线程被唤醒实现原理还是基于实现的一般用于固定资源比如连接池线程池等等类似计数器每次从线程中基于拿到资源使用完毕后基于归还资源类型的作用因为在中存在资源无法被正常使用的情况信号量中有资源但是线程通过无法获取基于类型的可以在唤醒当前线程后继续唤醒后续线程实现原理中的栅栏类似的原理等待指定数量的线程执行方法后一起并行去执行这些线程的后续任务是可以重置的也就是任务执行一次后可以重新反复使用当前的的的实现原理当线程获取到锁资源后基于挂起线程时会释放锁资源并且将当前线程封装到中的中的一个链表中当基于方法唤醒后会扔到的双向链表中阻塞队列基于数组实现的阻塞队列虚假唤醒在挂起线程判断的位置采用循环去解决虚假唤醒如果使用判断会造成多个线程在不满足情况下去向阻塞队列追加数据导致安全问题基于链表实现的阻塞队列基于数组实现的二叉堆基于二叉堆实现的优先级队列基于实现的阻塞队列基于实现的延迟队列要求插入的数据要实现接口不会将数组存放到指定位置生产者放数据就要一直等到消费者来消费的区别正常执行任务跟定时执行没关系延迟一段时间执行执行一次可以让任务在固定的周期下执行如果任务执行时间超过了延迟时间采用任务的执行时间作为周期这里会采用上次任务执行的时间点加上延迟时间作为下次任务的时间可以让任务在固定的周期下执行任务的处理时间影响下次执行时间是什么实现了异步非阻塞的效果就是在任务执行完毕后会主动通知不需要调用方主动会获取的后续任务是基于什么存储的栈为何不能保证后续任务的执行顺序因为任务是其他线程执行业务线程依然可以给设置后续任务如果在设置任务到栈结构之前前置任务已经执行完了就不需要再存放到栈结构了直接执行即可如果有时间一定要系统的看一下源码这样依赖八股文什么的就不用看了',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-07-10 16:30:49',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 20
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">简介</div><div class="back-menu-list"><a class="back-menu-item" href="https://yanruizhi.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">轻松一刻</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.jugege.cc/" title="看场电影"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="看场电影"/><span class="back-menu-item-text">看场电影</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.yikm.net/" title="小霸王"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://files.codelife.cc/website/5f4ca285aa121b0c2ac69ee8.png?x-oss-process=image/resize,limit_0,m_fill,w_100,h_100/quality,q_92/format,webp" alt="小霸王"/><span class="back-menu-item-text">小霸王</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">资料库</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://imgse.com/yanruizhi" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">Wizard</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=495199691&amp;server=netease&amp;type=playlist"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 我的追番</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cinemas/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 我的追剧</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div class="nav-button" id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" title="搜索🔍" accesskey="s"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span> 搜索</span></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/pay/wechat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src="/img/pay/wechat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/pay/alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/img/pay/alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/MarkDown/" style="font-size: 1.05rem;">MarkDown<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 1.05rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url">技术分享</a><i class="anzhiyufont anzhiyu-icon-angle-right post-meta-separator"></i><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E7%AC%94%E8%AE%B0/" itemprop="url">笔记</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>面试</span></a></span></div></div><h1 class="post-title" itemprop="name headline">并发编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-07-09T16:00:00.000Z" title="发表于 2025-07-10 00:00:00">2025-07-10</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-07-10T08:30:49.142Z" title="更新于 2025-07-10 16:30:49">2025-07-10</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">35.3k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>135分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="并发编程"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为安徽 合肥"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>安徽 合肥</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://yanruizhi.github.io/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"><header><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/" itemprop="url">技术分享</a><a class="post-meta-categories" href="/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/%E7%AC%94%E8%AE%B0/" itemprop="url">笔记</a><a href="/tags/%E9%9D%A2%E8%AF%95/" tabindex="-1" itemprop="url">面试</a><h1 id="CrawlerTitle" itemprop="name headline">并发编程</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Wizard小志</span><time itemprop="dateCreated datePublished" datetime="2025-07-09T16:00:00.000Z" title="发表于 2025-07-10 00:00:00">2025-07-10</time><time itemprop="dateCreated datePublished" datetime="2025-07-10T08:30:49.142Z" title="更新于 2025-07-10 16:30:49">2025-07-10</time></header><h1 id="一、并发编程"><a href="#一、并发编程" class="headerlink" title="一、并发编程"></a>一、<strong>并发编程</strong></h1><h2 id="并发编程三大特性"><a href="#并发编程三大特性" class="headerlink" title="并发编程三大特性"></a>并发编程三大特性</h2><h3 id="一、原子性、有序性、可见性"><a href="#一、原子性、有序性、可见性" class="headerlink" title="一、原子性、有序性、可见性"></a>一、原子性、有序性、可见性</h3><h4 id="1-1-原子性"><a href="#1-1-原子性" class="headerlink" title="1.1 原子性"></a>1.1 原子性</h4><p>数据库的事务：ACID</p>
<p>A：原子性-事务是一个最小的执行的单位，一次事务的多次操作要么都成功，要么都失败。</p>
<p>并发编程的原子性：一个或多个指令在CPU执行过程中不允许中断的。</p>
<p>i++;操作是原子性？</p>
<p>肯定不是：i++操作一共有三个指令</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/065abe2799a34b4b82179e024f4c1564.png" alt="image.png"></p>
<p>getfield：从主内存拉取数据到CPU寄存器</p>
<p>iadd：在寄存器内部对数据进行+1</p>
<p>putfield：将CPU寄存器中的结果甩到主内存中</p>
<p>如何保证i++是原子性的。</p>
<p>锁：synchronized，lock，Atomic（CAS）</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/b70915ea31874d96b855955a68ed3e5f.png" alt="image.png"></p>
<p>使用lock锁也会有类似的概念，也就是在操作i++的三个指令前，先基于AQS成功修改state后才可以操作</p>
<p>使用synchronized和lock锁时，可能会触发将线程挂起的操作，而这种操作会触发内核态和用户态的切换，从而导致消耗资源。</p>
<p>CAS方式就相对synchronized和lock锁的效率更高（也说不定），因为CAS不会触发线程挂起操作！</p>
<p>CAS：compare and swap</p>
<p>线程基于CAS修改数据的方式：先获取主内存数据，在修改之前，先比较数据是否一致，如果一致修改主内存数据，如果不一致，放弃这次修改</p>
<p>CAS就是比较和交换，而比较和交换是一个原子操作</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/4c9561880aee4b1490dd9f85a44693fd.png" alt="image.png"></p>
<p>CAS在Java层面就是Unsafe类中提供的一个native方法，这个方法只提供了CAS成功返回true，失败返回false，如果需要重试策略，自己实现！</p>
<p>CAS问题：</p>
<ul>
<li>CAS只能对一个变量的修改实现原子性。</li>
<li>CAS存在ABA问题。<ul>
<li>A线程修改主内存数据从1~2，卡在了获取1之后。</li>
<li>B线程修改主内存数据从1~2，完成。</li>
<li>C线程修改主内存数据从2~1，完成。</li>
<li>A线程执行CAS操作，发现主内存是1，没问题，直接修改</li>
<li>解决方案：加版本号</li>
</ul>
</li>
<li>在CAS执行次数过多，但是依旧无法实现对数据的修改，CPU会一直调度这个线程，造成对CPU的性能损耗<ul>
<li>synchronized的实现方式：CAS自旋一定次数后，如果还不成，挂起线程</li>
<li>LongAdder的实现方式：当CAS失败后，将操作的值，存储起来，后续一起添加</li>
</ul>
</li>
</ul>
<blockquote>
<p>CAS：在多核情况下，有lock指令保证只有一个线程在执行当前CAS</p>
</blockquote>
<h4 id="1-2-有序性"><a href="#1-2-有序性" class="headerlink" title="1.2 有序性"></a>1.2 有序性</h4><p>指令在CPU调度执行时，CPU会为了提升执行效率，在不影响结果的前提下，对CPU指令进行重新排序。</p>
<p>如果不希望CPU对指定进行重排序，怎么办？</p>
<p>可以对属性追加volatile修饰，就不会对当前属性的操作进行指令重排序。</p>
<p>什么时候指令重排：满足happens-before原则，即可重排序</p>
<p>单例模式-DCL双重判断。</p>
<p>申请内存，初始化，关联是正常顺序，如果CPU对指令重排，可能会造成</p>
<p>申请内存，关联，初始化，在还没有初始化时，其他线程来获取数据，导致获取到的数据虽然有地址引用，但是内部的数据还没初始化，都是默认值，导致使用时，可能出现与预期不符的结果</p>
<h4 id="1-3-可见性"><a href="#1-3-可见性" class="headerlink" title="1.3 可见性"></a>1.3 可见性</h4><p>可见性：前面说过CPU在处理时，需要将主内存数据甩到我的寄存机中再执行指令，指向完指令后，需要将寄存器数据扔回到主内存中。倒是寄存器数据同步到主内存是遵循MESI协议的，说人话就是，</p>
<p>不是每次操作结束就将CPU缓存数据同步到主内存。造成多个线程看到的数据不一样。</p>
<p>volatile每次操作后，立即同步数据到主内存。</p>
<p>synchronized，触发同步数据到主内存。</p>
<p>final，也可以解决可见性问题。</p>
<h3 id="二、synchronized使用"><a href="#二、synchronized使用" class="headerlink" title="二、synchronized使用"></a>二、synchronized使用</h3><h4 id="2-1-synchronized的使用方式"><a href="#2-1-synchronized的使用方式" class="headerlink" title="2.1 synchronized的使用方式"></a>2.1 synchronized的使用方式</h4><p>synchronized方法</p>
<p>synchronized代码块</p>
<p>类锁和对象锁：</p>
<p>类锁：基础当前类的Class加锁</p>
<p>对象锁：基于this对象加锁</p>
<p>synchronized是互斥锁，每个线程获取synchronized时，基于synchronized绑定的对象去获取锁！</p>
<p><strong>synchronized锁是基于对象实现的！</strong></p>
<p>synchronized是如何基于对象实现的互斥锁，先了解对象再内存中是如何存储的。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/580d7b20593a492991c3eeed8dd14f6e.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/9d97cd3870e749508521a7992ca48f35.png" alt="image.png"></p>
<p>在Java中查看。</p>
<p>导入依赖：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jol<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jol-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>查看对象信息</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/29d5d974cb9c42d88661d04637243911.png" alt="image.png"></p>
<p>初始化的对象是无锁状态</p>
<h3 id="三、synchronized锁升级"><a href="#三、synchronized锁升级" class="headerlink" title="三、synchronized锁升级"></a>三、synchronized锁升级</h3><p>synchronized在jdk1.6之前，一直是重量级锁：只要线程获取锁资源失败，直接挂起线程（用户-内核）</p>
<p>在jdk1.6之前synchronized效率贼低，再加上Doug Lea推出了ReentrantLock，效率比synchronized快多了，导致JDK团队不得不在jdk1.6将synchronized做优化</p>
<p>锁升级：</p>
<ul>
<li>无锁状态、匿名偏向状态：没有线程拿锁。</li>
<li>偏向锁状态：没有线程的竞争，只有一个线程再获取锁资源。<br><strong>线程竞争锁资源时，发现当前synchronized没有线程占用锁资源，并且锁是偏向锁，使用CAS的方式，设置o的线程ID为当前线程，获取到锁资源，下次当前线程再次获取时，只需要判断是偏向锁，并且线程ID是当前线程ID即可，直接获得到锁资源。</strong></li>
<li>轻量级锁：偏向锁出现竞争时，会升级到轻量级锁（触发偏向锁撤销）。<br><strong>轻量级锁的状态下，线程会基于CAS的方式，尝试获取锁资源，CAS的次数是基于自适应自旋锁实现的，JVM会自动的基于上一次获取锁是否成功，来决定这次获取锁资源要CAS多少次。</strong></li>
<li>重量级锁：轻量级锁CAS一段次数后，没有拿到锁资源，升级为重量级锁（其实CAS操作是在重量级锁时执行的）。<br><strong>重量级锁就是线程拿不到锁，就挂起。</strong></li>
</ul>
<p>偏向锁是延迟开启的，并且在开启偏向锁之后，默认不存在无锁状态，只存在匿名偏向synchronized因为不存在从重量级锁降级到偏向或者是轻量。</p>
<blockquote>
<p>synchronized在偏向锁升级到轻量锁时，会涉及到偏向锁撤销，需要等到一个安全点，stw，才可以撤销，并发偏向锁撤销比较消耗资源<br>在程序启动时，偏向锁有一个延迟开启的操作，因为项目启动时，ClassLoader会加载.class文件，这里会涉及到synchronized操作，<br>为了避免启动时，涉及到偏向锁撤销，导致启动效率变慢，所以程序启动时，默认不是开启偏向锁的。<br>如果在开启偏向锁的情况下，查看对象，默认对象是匿名偏向。</p>
</blockquote>
<p>编译器优化的结果，出现了下列效果</p>
<p>锁消除：线程在执行一段synchronized代码块时，发现没有共享数据的操作，自动帮你把synchronized去掉。</p>
<p>锁膨胀：在一个多次循环的操作中频繁的获取和释放锁资源，synchronized在编译时，可能会优化到循环外部。</p>
<h3 id="四、synchronized-ObjectMonitor"><a href="#四、synchronized-ObjectMonitor" class="headerlink" title="四、synchronized-ObjectMonitor"></a>四、synchronized-ObjectMonitor</h3><p>涉及ObjectMonitor一般是到达了重量级锁才会涉及到。</p>
<p>在到达重量级锁之后，重量级锁的指针会指向ObjectMonitor对象。</p>
<p><a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/69087d08d473/src/share/vm/runtime/objectMonitor.hpp">http://hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/69087d08d473/src/share/vm/runtime/objectMonitor.hpp</a></p>
<figure class="highlight hpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">  _header       = <span class="literal">NULL</span>;</span><br><span class="line">  _count        = <span class="number">0</span>;     <span class="comment">// 抢占锁资源的线程个数</span></span><br><span class="line">  _waiters      = <span class="number">0</span>,     <span class="comment">// 调用wait的线程个数。</span></span><br><span class="line">  _recursions   = <span class="number">0</span>;     <span class="comment">// 可重入锁标记，</span></span><br><span class="line">  _object       = <span class="literal">NULL</span>; </span><br><span class="line">  _owner        = <span class="literal">NULL</span>;  <span class="comment">// 持有锁的线程</span></span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>;  <span class="comment">// wait的线程  （双向链表）</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;  <span class="comment">// 假定的继承人（锁释放后，被唤醒的线程，有可能拿到锁资源）</span></span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ;  <span class="comment">// 挂起线程存放的位置。（单向链表）</span></span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ;  <span class="comment">// _cxq会在一定的机制下，将_cxq里的等待线程扔到当前_EntryList里。  （双向链表）</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">  _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>偏向锁会降级到无锁状态嘛？怎么降？</p>
<p>会，当偏向锁状态下，获取当前对象的hashcode值，会因为对象头空间无法存储hashcode，导致降级到无锁状态。</p>
<h1 id="二、ReentrantLock源码"><a href="#二、ReentrantLock源码" class="headerlink" title="二、ReentrantLock源码"></a>二、<strong>ReentrantLock源码</strong></h1><h3 id="一、ReentrantLock介绍"><a href="#一、ReentrantLock介绍" class="headerlink" title="一、ReentrantLock介绍"></a><strong>一、ReentrantLock介绍</strong></h3><p>Java中提供锁，一般就是synchronized和lock锁，ReentrantLock是互斥锁，跟synchronized一样。</p>
<p>如果竞争比较激烈，推荐lock锁，效率更高</p>
<p>如果几乎没有竞争，推荐synchronized</p>
<p>原因：synchronized只有锁升级，当升级到重量级锁后，无法降级到轻量级、偏向锁。</p>
<p>lock锁的使用相对synchronized成本更高。</p>
<p>synchronized是非公平锁，lock是公平+非公平锁</p>
<p>lock锁提供的功能更完善，lock可以使用tryLock指定等待锁的时间</p>
<p>lock锁还提供了lockInterruptibly允许线程在获取锁的期间被中断。</p>
<p>synchronized基于对象实现，lock锁基于AQS+CAS实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 业务代码</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、ReentrantLock的lock方法源码"><a href="#二、ReentrantLock的lock方法源码" class="headerlink" title="二、ReentrantLock的lock方法源码"></a>二、<strong>ReentrantLock的lock方法源码</strong></h3><p>清楚lock方法是如何实现让当前线程获取到锁资源（什么效果算是拿到了锁资源）</p>
<p>非公平锁：上来先尝试将state从0修改为1，如果成功，代表获取锁资源。如果没有成功，调用acquire</p>
<p>公平锁：调用acquire</p>
<p>state是个什么鬼？</p>
<p>state是AQS中的一个由volatile修饰的int类型变量，多个线程会通过CAS的方式修改state，在并发情况下，只会有一个线程成功的修改state（从0~1）</p>
<p>如果线程修改state失败怎么办？</p>
<p>如果线程没有拿到锁资源，会到AQS的双向链表中排队等待（在期间，线程可能会挂起）</p>
<p>AQS的双向链表（队列）是个啥？</p>
<p>AQS中的双向链表是基于内部类Node在维护，Node中包含prev，next，thread属性，并且在AQS中还有两个属性，分别是head，tail。</p>
<p>画一下AQS的核心</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/2ccd93634b77487cafe88d7e8e809def.png" alt="image.png"></p>
<p>公平&amp;非公平的方法源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁的sync的lock方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁的sync的lock方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、ReentrantLock的acquire方法源码"><a href="#三、ReentrantLock的acquire方法源码" class="headerlink" title="三、ReentrantLock的acquire方法源码"></a>三、<strong>ReentrantLock的acquire方法源码</strong></h3><p>acquire是一个业务方法，里面并没有实际的业务处理，都是在调用其他方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心acquire     arg = 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 调用tryAcquire方法：尝试获取锁资源（非公平、公平），拿到锁资源，返回true，直接结束方法。 没有拿到锁资源，</span></span><br><span class="line">    <span class="comment">//   需要执行&amp;&amp;后面的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 当没有获取锁资源后，会先调用addWaiter：会将没有获取到锁资源的线程封装为Node对象，</span></span><br><span class="line">    <span class="comment">//   并且插入到AQS的队列的末尾，并且作为tail</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 继续调用acquireQueued方法，查看当前排队的Node是否在队列的前面，如果在前面（head的next），尝试获取锁资源</span></span><br><span class="line">    <span class="comment">//   如果没在前面，尝试将线程挂起，阻塞起来！</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、ReentrantLock的tryAcquire方法"><a href="#四、ReentrantLock的tryAcquire方法" class="headerlink" title="四、ReentrantLock的tryAcquire方法"></a>四、<strong>ReentrantLock的tryAcquire方法</strong></h3><p>tryAcquire分为公平和非公平两种、</p>
<p>tryAcquire主要做了两件事：</p>
<ul>
<li>如果state为0，尝试获取锁资源</li>
<li>如果state不为0，看一下是不是锁重入操作</li>
</ul>
<p>非公平：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非公平锁实现！</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到AQS的state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 如果state == 0，说明没有线程占用着当前的锁资源</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 没人占用锁资源，我直接抢一波（不管有没有线程在排队）</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            <span class="comment">// 将当前占用这个互斥锁的线程属性设置为当前线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="comment">// 返回true，拿锁成功</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前state != 0，说明有线程占用着锁资源</span></span><br><span class="line">    <span class="comment">// 判断拿着锁的线程是不是当前线程（锁重入）</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="comment">// 将state再次+1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="comment">// 锁重入是否超过最大限制</span></span><br><span class="line">        <span class="comment">// 01111111 11111111 11111111 11111111   + 1</span></span><br><span class="line">        <span class="comment">// 10000000 00000000 00000000 00000000</span></span><br><span class="line">        <span class="comment">// 抛出error</span></span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 将值设置给state</span></span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="comment">// 返回true，拿锁成功</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>公平锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁实现</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到AQS的state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 阿巴阿巴~~~~</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断是否有线程在排队，如果有线程排队，返回true，配上前面的!，那会直接不执行返回最外层的false</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            <span class="comment">// 如果没有线程排队，直接CAS尝试获取锁资源</span></span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、ReentrantLock的addWaiter方法"><a href="#五、ReentrantLock的addWaiter方法" class="headerlink" title="五、ReentrantLock的addWaiter方法"></a>五、<strong>ReentrantLock的addWaiter方法</strong></h3><p>在获取锁资源失败后，需要将当前线程封装为Node对象，并且插入到AQS队列的末尾</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前线程封装为Node对象，并且插入到AQS队列的末尾</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">addWaiter</span><span class="params">(Node mode)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装为Node对象，mode为null，代表互斥锁</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// pred是tail节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">pred</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="comment">// 如果pred不为null，有线程正在排队</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将当前节点的prev，指定tail尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 以CAS的方式，将当前节点变为tail节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 之前的tail的next指向当前节点</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加的流程为，  自己prev指向、tail指向自己、前节点next指向我</span></span><br><span class="line">    <span class="comment">// 如果上述方式，CAS操作失败，导致加入到AQS末尾失败，如果失败，就基于enq的方式添加到AQS队列</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// enq，无论怎样都添加进入</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到tail</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 如果tail为null，说明当前没有Node在队列中</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 创建一个新的Node作为head，并且将tail和head指向一个Node</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 和上述代码一致！</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、ReentrantLock的acquireQueued"><a href="#六、ReentrantLock的acquireQueued" class="headerlink" title="六、ReentrantLock的acquireQueued"></a>六、<strong>ReentrantLock的acquireQueued</strong></h3><p>acquireQueued方法会查看当前排队的Node是否是head的next，如果是，尝试获取锁资源，如果不是或者获取锁资源失败那么就尝试将当前Node的线程挂起（unsafe.park()）</p>
<p>在挂起线程前，需要确认当前节点的上一个节点的状态必须是小于等于0，</p>
<p>如果为1，代表是取消的节点，不能挂起</p>
<p>如果为-1，代表挂起当前线程</p>
<p>如果为-2，-3，需要将状态改为-1之后，才能挂起当前线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// acquireQueued方法</span></span><br><span class="line"><span class="comment">// 查看当前排队的Node是否是head的next，</span></span><br><span class="line"><span class="comment">// 如果是，尝试获取锁资源，</span></span><br><span class="line"><span class="comment">// 如果不是或者获取锁资源失败那么就尝试将当前Node的线程挂起（unsafe.park()）</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 标识。</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 循环走起</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 拿到上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; <span class="comment">// 说明当前节点是head的next</span></span><br><span class="line">                tryAcquire(arg)) &#123; <span class="comment">// 竞争锁资源，成功：true，失败：false</span></span><br><span class="line">                <span class="comment">// 进来说明拿到锁资源成功</span></span><br><span class="line">                <span class="comment">// 将当前节点置位head，thread和prev属性置位null</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 帮助快速GC</span></span><br><span class="line">                p.next = <span class="literal">null</span>; </span><br><span class="line">                <span class="comment">// 设置获取锁资源成功</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 不管线程中断。</span></span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果不是或者获取锁资源失败,尝试将线程挂起</span></span><br><span class="line">            <span class="comment">// 第一个事情，当前节点的上一个节点的状态正常！</span></span><br><span class="line">            <span class="comment">// 第二个事情，挂起线程</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">				<span class="comment">// 通过LockSupport将当前线程挂起</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确保上一个节点状态是正确的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到上一个节点的状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果上一个节点为 -1</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 返回true，挂起线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果上一个节点是取消状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环往前找，找到一个状态小于等于0的节点</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将小于等于0的节点状态该为-1</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、ReentrantLock的unlock方法"><a href="#七、ReentrantLock的unlock方法" class="headerlink" title="七、ReentrantLock的unlock方法"></a>七、<strong>ReentrantLock的unlock方法</strong></h3><p>释放锁资源：</p>
<ul>
<li>将state-1。</li>
<li>如果state减为0了，唤醒在队列中排队的Node。（一定唤醒离head最近的）</li>
</ul>
<p>释放锁不分公平和非公平，就一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真正释放锁资源的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 核心的释放锁资源方法</span></span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放锁资源释放干净了。  （state == 0）</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 如果头节点不为null，并且头节点的状态不为0，唤醒排队的线程</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)、</span><br><span class="line">            <span class="comment">// 唤醒线程</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放锁成功，但是state != 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心的释放锁资源方法</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取state - 1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">    <span class="comment">// 如果释放锁的线程不是占用锁的线程，抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 是否成功的将锁资源释放利索 （state == 0）</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 锁资源释放干净。</span></span><br><span class="line">        free = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 将占用锁资源的属性设置为null</span></span><br><span class="line">        setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将state赋值</span></span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="comment">// 返回true，代表释放干净了</span></span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到头节点状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="comment">// 如果头节点状态小于0，换为0</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 拿到当前节点的next</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 如果s == null ，或者s的状态为1</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// next节点不需要唤醒，需要唤醒next的next</span></span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从尾部往前找，找到状态正常的节点。（小于等于0代表正常状态）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 经过循环的获取，如果拿到状态正常的节点，并且不为null</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么唤醒线程时，为啥从尾部往前找，而不是从前往后找？</p>
<p>因为在addWaiter操作时，是先将当前Node的prev指针指向前面的节点，然后是将tail赋值给当前Node，最后才是能上一个节点的next指针，指向当前Node。</p>
<p>如果从前往后，通过next去找，可能会丢失某个节点，导致这个节点不会被唤醒~</p>
<p>如果从后往前找，肯定可以找到全部的节点。</p>
<h1 id="三、ReentrantReadWriteLock读写锁源码"><a href="#三、ReentrantReadWriteLock读写锁源码" class="headerlink" title="三、ReentrantReadWriteLock读写锁源码"></a>三、<strong>ReentrantReadWriteLock读写锁源码</strong></h1><h3 id="一、为什么要出现读写锁"><a href="#一、为什么要出现读写锁" class="headerlink" title="一、为什么要出现读写锁"></a>一、为什么要出现读写锁</h3><p>因为ReentrantLock是互斥锁，如果有一个操作是读多写少，同时还需要保证线程安全，那么使用ReentrantLock会导致效率比较低。</p>
<p>因为多个线程在对同一个数据进行读操作时，也不会造成线程安全问题。</p>
<p>所以出现了ReentrantReadWriteLock锁：</p>
<p>读读操作是共享的。</p>
<p>写写操作是互斥的。</p>
<p>读写操作是互斥的。</p>
<p>写读操作是互斥的。</p>
<p>单个线程获取写锁后，再次获取读锁，可以拿到。（写读可重入）</p>
<p>单个线程获取读锁后，再次获取写锁，拿不到。（读写不可重入）</p>
<p>使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxxTest</span> &#123;</span><br><span class="line">    <span class="comment">// 读写锁！</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写锁</span></span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">writeLock</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">static</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">readLock</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        readLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拿到读锁！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        writeLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;拿到写锁！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、读写锁的核心思想"><a href="#二、读写锁的核心思想" class="headerlink" title="二、读写锁的核心思想"></a>二、读写锁的核心思想</h3><p>ReentrantReadWriteLock还是基于AQS实现的。很多功能的实现和ReentrantLock类似</p>
<p>还是基于AQS的state来确定当前线程是否拿到锁资源</p>
<p>state表示读锁：将state的高16位作为读锁的标识</p>
<p>state表示写锁：将state的低16位作为写锁的标识</p>
<p>锁重入问题：</p>
<ul>
<li>写锁重入怎么玩：因为写操作和其他操作是互斥的，代表同一时间，只有一个线程持有着写锁，只要锁重入，就对低位+1即可。而且锁重入的限制，从原来的2^31 - 1，变为了2 ^ 16 -1。变短了~~</li>
<li>读锁重入怎么玩：读锁的重入不能仿照写锁的方式，因为写锁属于互斥锁，同一时间只会有一个线程持有写锁，但是读锁是共享锁，同一时间会有多个线程持有读锁。所以每个获取到读锁的线程，记录锁重入的方式都是基于自己的ThreadLocal存储锁重入次数。</li>
</ul>
<p>读锁重入的时候就不操作state了？不对，每次锁重入还要修改state，只是记录当前线程锁重入的次数，需要基于ThreadLocal记录</p>
<p>00000000 00000000 00000000 00000000 ： state</p>
<p>写锁：</p>
<p>00000000 00000000 00000000 00000001</p>
<p>写锁：</p>
<p>00000000 00000000 00000000 00000010</p>
<p>A读锁：拿不到，排队</p>
<p>00000000 00000000 00000000 00000010</p>
<p>写锁全部释放（唤醒）</p>
<p>00000000 00000000 00000000 00000000</p>
<p>A读锁：</p>
<p>00000000 00000001 00000000 00000000</p>
<p>B读锁：</p>
<p>00000000 00000010 00000000 00000000</p>
<p>B再次读锁：</p>
<p>00000000 00000011 00000000 00000000</p>
<p>每个读操作的线程，在获取读锁时，都需要开辟一个ThreadLocal。读写锁为了优化这个事情，做了两手操作：</p>
<ul>
<li>第一个拿到读锁的线程，不用ThreadLocal记录重入次数，在读写锁内有有一个firstRead记录重入次数</li>
<li>还记录了最后一个拿到读锁的线程的重入次数，交给cachedHoldCounter属性标识，可以避免频繁的在锁重入时，从TL中获取</li>
</ul>
<h3 id="三、写锁的操作"><a href="#三、写锁的操作" class="headerlink" title="三、写锁的操作"></a>三、写锁的操作</h3><h4 id="3-1-写锁加锁-acquire"><a href="#3-1-写锁加锁-acquire" class="headerlink" title="3.1 写锁加锁-acquire"></a>3.1 写锁加锁-acquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 尝试获取锁资源（看一下，能否以CAS的方式将state 从0 ~ 1，改成功，拿锁成功）</span></span><br><span class="line">    <span class="comment">// 成功走人</span></span><br><span class="line">    <span class="comment">// 不成功执行下面方法</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        <span class="comment">// addWaiter：将当前没按到锁资源的，封装成Node，排到AQS里</span></span><br><span class="line">        <span class="comment">// acquireQueued：当前排队的能否竞争锁资源，不能挂起线程阻塞</span></span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为都是AQS的实现，主要看tryAcquire</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// state，高16：读，低16：写</span></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000001</span> <span class="number">00000000</span> <span class="number">00000000</span> - SHARED_UNIT</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">11111111</span> - MAX_COUNT</span><br><span class="line"></span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">11111111</span> <span class="number">11111111</span> - EXCLUSIVE_MASK</span><br><span class="line">&amp;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000001</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_SHIFT</span>   <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_UNIT</span>    <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span>      <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCLUSIVE_MASK</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只拿到表示读锁的高16位。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sharedCount</span><span class="params">(<span class="type">int</span> c)</span>    &#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">// 只拿到表示写锁的低16位。</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="title function_">exclusiveCount</span><span class="params">(<span class="type">int</span> c)</span> &#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读写锁的写锁，获取流程</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到state</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">    <span class="comment">// 拿到了写锁的低16位标识w</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> exclusiveCount(c);</span><br><span class="line">    <span class="comment">// c != 0：要么有读操作拿着锁，要么有写操作拿着锁</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果w == 0，代表没有写锁，拿不到！拜拜！</span></span><br><span class="line">        <span class="comment">// 如果w != 0，代表有写锁，看一下拿占用写锁是不是当前线程，如果不是，拿不到！拜拜！</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 到这，说明肯定是写锁，并且是当前线程持有</span></span><br><span class="line">        <span class="comment">// 判断对低位 + 1，是否会超过MAX_COUNT，超过抛Error</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// 如果没超过锁重入次数， + 1，返回true，拿到锁资源。</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到这，说明c == 0</span></span><br><span class="line">    <span class="comment">// 读写锁也分为公平锁和非公平锁</span></span><br><span class="line">    <span class="comment">// 公平：看下排队不，排队就不抢了</span></span><br><span class="line">    <span class="comment">// 走hasQueuedPredecessors方法，有排队的返回true，没排队的返回false</span></span><br><span class="line">    <span class="comment">// 非公平：直接抢！</span></span><br><span class="line">    <span class="comment">// 方法实现直接返回false</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        <span class="comment">// 以CAS的方式，将state从0修改为 1</span></span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="comment">// 要么不让抢，要么CAS操作失败，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将当前持有互斥锁的线程，设置为自己</span></span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="剩下的addWaiter和acquireQueued和ReentrantLock看的一样，都是AQS自身提供的方法"><a href="#剩下的addWaiter和acquireQueued和ReentrantLock看的一样，都是AQS自身提供的方法" class="headerlink" title="剩下的addWaiter和acquireQueued和ReentrantLock看的一样，都是AQS自身提供的方法"></a>剩下的addWaiter和acquireQueued和ReentrantLock看的一样，都是AQS自身提供的方法</h5><h4 id="3-2-写锁-释放锁操作"><a href="#3-2-写锁-释放锁操作" class="headerlink" title="3.2 写锁-释放锁操作"></a>3.2 写锁-释放锁操作</h4><p>读写锁的释放操作，跟ReentrantLock一致，只是需要单独获取低16位，判断是否为0，为0就释放成功</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">// 写锁的释放锁</span><br><span class="line">public final boolean release(int arg) &#123;</span><br><span class="line">    // 只有tryRealse是读写锁重新实现的方法，其他的和ReentrantLock一致</span><br><span class="line">    if (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 读写锁的真正释放</span><br><span class="line">protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">    // 判断释放锁的线程是不是持有锁的线程</span><br><span class="line">    if (!isHeldExclusively())</span><br><span class="line">        // 不是抛异常</span><br><span class="line">        throw new IllegalMonitorStateException();</span><br><span class="line">    // 对state - 1</span><br><span class="line">    int nextc = getState() - releases;</span><br><span class="line">    // 拿着next从获取低16位的值，判断是否为0</span><br><span class="line">    boolean free = exclusiveCount(nextc) == 0;</span><br><span class="line">    // 返回true</span><br><span class="line">    if (free)</span><br><span class="line">        // 将持有互斥锁的线程信息置位null</span><br><span class="line">        setExclusiveOwnerThread(null);</span><br><span class="line">    // 将-1之后的nextc复制给state</span><br><span class="line">    setState(nextc);</span><br><span class="line">    return free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、读锁的操作"><a href="#四、读锁的操作" class="headerlink" title="四、读锁的操作"></a>四、读锁的操作</h3><h4 id="4-1-读锁的加锁操作"><a href="#4-1-读锁的加锁操作" class="headerlink" title="4.1 读锁的加锁操作"></a>4.1 读锁的加锁操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line">// 读锁加锁操作</span><br><span class="line">public final void acquireShared(int arg) &#123;</span><br><span class="line">    // tryAcquireShared，尝试获取锁资源，获取到返回1，没获取到返回-1</span><br><span class="line">    if (tryAcquireShared(arg) &lt; 0)</span><br><span class="line">        // doAcquireShared 前面没拿到锁，这边需要排队~</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// tryAcquireShared方法</span><br><span class="line">protected final int tryAcquireShared(int unused) &#123;</span><br><span class="line">    // 获取当前线程</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    // 拿到state</span><br><span class="line">    int c = getState();</span><br><span class="line">    // 那写锁标识，如果 !=0，代表有写锁</span><br><span class="line">    if (exclusiveCount(c) != 0 &amp;&amp;</span><br><span class="line">        // 如果持有写锁的不是当前线程，排队去！</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        // 排队！</span><br><span class="line">        return -1;</span><br><span class="line">    // 没有写锁！</span><br><span class="line">    // 获取读锁信息</span><br><span class="line">    int r = sharedCount(c);</span><br><span class="line">    // 公平锁： 有人排队，返回true，直接拜拜，没人排队，返回false</span><br><span class="line">    // 非公平锁：正常的逻辑是非公平直接抢，因为是读锁，每次抢占只要CAS成功，必然成功</span><br><span class="line">    // 这就会出现问题，写操作无法在读锁的情况抢占资源，导致写线程饥饿，一致阻塞…………</span><br><span class="line">    // 非公平锁会查看next是否是写锁的，如果是，返回true，如果不是返回false</span><br><span class="line">    if (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        // 查看读锁是否已经达到了最大限制</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        // 以CAS的方式，对state的高16位+1</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        // 拿到锁资源成功！！！</span><br><span class="line">        if (r == 0) &#123;</span><br><span class="line">            // 第一个拿到锁资源的线程，用first存储</span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = 1;</span><br><span class="line">        &#125; else if (firstReader == current) &#123;</span><br><span class="line">            // 我是锁重入，我就是第一个拿到读锁的线程，直接对firstReaderHoldCount++记录重入的次数</span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // 不是第一个拿到锁资源的</span><br><span class="line">            // 先拿到cachedHoldCounter，最后一个线程的重入次数</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            // rh == null： 我是第二个拿到读锁的！</span><br><span class="line">            // 或者发现之前有最后一个来的，但是不我，将我设置为最后一个。</span><br><span class="line">            if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                // 获取自己的重入次数，并赋值给cachedHoldCounter</span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            // 之前拿过，现在如果为0，赋值给TL</span><br><span class="line">            else if (rh.count == 0)</span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            // 重入次数+1，</span><br><span class="line">            // 第一个：可能是第一次拿</span><br><span class="line">            // 第二个：可能是重入操作</span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过tryAcquireShared没拿到锁资源，也没返回-1，就走这</span><br><span class="line">final int fullTryAcquireShared(Thread current) &#123;</span><br><span class="line">    HoldCounter rh = null;</span><br><span class="line">    for (;;) &#123;</span><br><span class="line">        // 拿state</span><br><span class="line">        int c = getState();</span><br><span class="line">        // 现在有互斥锁，不是自己，拜拜！</span><br><span class="line">        if (exclusiveCount(c) != 0) &#123;</span><br><span class="line">            if (getExclusiveOwnerThread() != current)</span><br><span class="line">                return -1;</span><br><span class="line">   </span><br><span class="line">        // 公平：有排队的，进入逻辑。   没排队的，过！</span><br><span class="line">        // 非公平：head的next是写不，是，进入逻辑。   如果不是，过！</span><br><span class="line">        &#125; else if (readerShouldBlock()) &#123;</span><br><span class="line">            // 这里代码特别乱，因为这里的代码为了处理JDK1.5的内存泄漏问题，修改过~</span><br><span class="line">            // 这个逻辑里不会让你拿到锁，做被阻塞前的准备</span><br><span class="line">            if (firstReader == current) &#123;</span><br><span class="line">                // 什么都不做</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null) &#123;</span><br><span class="line">                    // 获取最后一个拿到读锁资源的</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        // 拿到我自己的记录重入次数的。</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        // 如果我的次数是0，绝对不是重入操作！</span><br><span class="line">                        if (rh.count == 0)</span><br><span class="line">                            // 将我的TL中的值移除掉，不移除会造成内存泄漏</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                // 如果我的次数是0，绝对不是重入操作！</span><br><span class="line">                if (rh.count == 0)</span><br><span class="line">                    // 返回-1，等待阻塞吧！</span><br><span class="line">                    return -1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 超过读锁的最大值了没？</span><br><span class="line">        if (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">        // 到这，就CAS竞争锁资源</span><br><span class="line">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            // 跟tryAcquireShared一模一样</span><br><span class="line">            if (sharedCount(c) == 0) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = 1;</span><br><span class="line">            &#125; else if (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (rh == null)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                if (rh == null || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                else if (rh.count == 0)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; </span><br><span class="line">            &#125;</span><br><span class="line">            return 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-加锁-扔到队列准备阻塞操作"><a href="#4-2-加锁-扔到队列准备阻塞操作" class="headerlink" title="4.2 加锁-扔到队列准备阻塞操作"></a>4.2 加锁-扔到队列准备阻塞操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没拿到锁，准备挂起</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装为Node，当前Node为共享锁，并添加到队列的模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取上一个节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 如果我的上一个是head，尝试再次获取锁资源</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果r大于等于0，代表获取锁资源成功</span></span><br><span class="line">                    <span class="comment">// 唤醒AQS中我后面的要获取读锁的线程（SHARED模式的Node）</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; </span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 能否挂起当前线程，需要保证我前面Node的状态为-1，才能执行后面操作</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                <span class="comment">//LockSupport.park挂起~~</span></span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="四、线程池源码"><a href="#四、线程池源码" class="headerlink" title="四、线程池源码"></a>四、<strong>线程池源码</strong></h1><h3 id="一、线程池介绍"><a href="#一、线程池介绍" class="headerlink" title="一、线程池介绍"></a>一、线程池介绍</h3><p>Java构建线程的方式</p>
<ul>
<li>new Thread</li>
<li>new  Runnable</li>
<li>new Callable</li>
</ul>
<p>为了避免频繁创建和销毁线程造成不必要的性能，一般在使用线程时，会采用线程池</p>
<p>核心线程数设置的方案：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/044e930918a6451aa7af1f9ea5ce05b2.png" alt="image.png"></p>
<p>线程池使用方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程池的核心线程数如何设置</span></span><br><span class="line">    <span class="comment">// 任务可以分为两种：CPU密集，IO密集。</span></span><br><span class="line">    <span class="type">ThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            TimeUnit.SECONDS,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1</span>),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadFactory</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable r)</span> &#123;</span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    executor.execute(任务);</span><br><span class="line">    executor.submit(有返回结果的任务);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、线程池核心属性认知"><a href="#二、线程池核心属性认知" class="headerlink" title="二、线程池核心属性认知"></a>二、线程池核心属性认知</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AtomicInteger,就是一个int，写操作用CAS实现，保证了原子性</span></span><br><span class="line"><span class="comment">// ctl维护这线程池的2个核心内容：</span></span><br><span class="line"><span class="comment">// 1：线程池状态（高3位，维护着线程池状态）</span></span><br><span class="line"><span class="comment">// 2：工作线程数量（核心线程+非核心线程，低29位，维护着工作线程个数）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// COUNT_BITS=29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 工作线程的最大个数</span></span><br><span class="line"><span class="comment">// 00100000 00000000 00000000 00000000 - 1</span></span><br><span class="line"><span class="comment">// 000111111111111111111111111111111  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拿到线程池状态</span></span><br><span class="line"><span class="comment">// 011... </span></span><br><span class="line"><span class="comment">// 111...</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">// 拿到工作线程个数</span></span><br><span class="line"><span class="comment">// ...0000000111111</span></span><br><span class="line"><span class="comment">// ...1111111111111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br></pre></td></tr></table></figure>
<p>线程池状态</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/dd9801338d9141aeaf820c1080cc10f0.png" alt="image.png"></p>
<h3 id="三、execute方法"><a href="#三、execute方法" class="headerlink" title="三、execute方法"></a>三、execute方法</h3><p>通过execute方法，可以看到线程池处理任务的整体执行流程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    <span class="comment">// 非空！！</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 拿到ctl</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">// 通过ctl获取当前工作线程个数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="comment">// true：代表是核心线程，false：代表是非核心线程</span></span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="literal">true</span>))</span><br><span class="line">            <span class="comment">// 如果添加核心线程成功，return结束掉</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 如果添加失败，重新获取ctl</span></span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心线程数已经到了最大值、添加时，线程池状态变为SHUTDOWN/STOP</span></span><br><span class="line">    <span class="comment">// 判断线程池是否是运行状态 &amp;&amp; 添加任务到工作队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 再次获取ctl的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">recheck</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="comment">// 再次判断线程池状态。  DCL</span></span><br><span class="line">        <span class="comment">// 如果状态不是RUNNING，把任务从工作队列移除。</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            <span class="comment">// 走一波拒绝策略。</span></span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 线程池状态是RUNNING。</span></span><br><span class="line">        <span class="comment">// 判断工作线程数是否是0个。</span></span><br><span class="line">        <span class="comment">// 可以将核心线程设置为0，所有工作线程都是非核心线程。</span></span><br><span class="line">        <span class="comment">// 核心线程也可以通过keepAlived超时被销毁，所以如果恰巧核心线程被销毁，也会出现当前效果</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 添加空任务的非核心线程去处理工作队列中的任务</span></span><br><span class="line">            addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可能工作队列中的任务存满了，没添加进去，到这就要添加非核心线程去处理任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="literal">false</span>))</span><br><span class="line">        <span class="comment">// 执行拒绝策略！</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、addWorker添加工作线程"><a href="#四、addWorker添加工作线程" class="headerlink" title="四、addWorker添加工作线程"></a>四、addWorker添加工作线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">addWorker</span><span class="params">(Runnable firstTask, <span class="type">boolean</span> core)</span> &#123;</span><br><span class="line">    xxx:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 阿巴阿巴…………</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line">        <span class="comment">// 判断线程池状态</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">              <span class="comment">// 判断如果线程池的状态为SHUTDOWN，还要处理工作队列中的任务</span></span><br><span class="line">              <span class="comment">// 如果你添加工作线程的方式，是任务的非核心线程，并且工作队列还有任务</span></span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span> &amp;&amp; ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断工作线程个数</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 阿巴阿巴……</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line">            <span class="comment">// 判断1：工作线程是否已经 == 工作线程最大个数</span></span><br><span class="line">            <span class="comment">// 判断2-true判断：判断是核心线程么？如果是判断是否超过核心线程个数</span></span><br><span class="line">            <span class="comment">// 判断2-false判断：如果是非核心线程，查看是否超过设置的最大线程数</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 对工作线程进行 + 1操作</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="comment">// +1成功，跳出外层循环，执行添加工作线程的业务</span></span><br><span class="line">                <span class="comment">// 以CAS方式，对ctl+1，多线程并发操作，只有会有一个成功</span></span><br><span class="line">                <span class="keyword">break</span> xxx;</span><br><span class="line">            <span class="comment">// 重新拿ctl，</span></span><br><span class="line">            c = ctl.get();</span><br><span class="line">            <span class="comment">// 判断线程池状态是否有变化</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> xxx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加工作线程的业务  </span></span><br><span class="line">    <span class="comment">// 工作线程启动了吗？</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerStarted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="comment">// 工作线程添加了吗？</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">workerAdded</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// Worker就是工作线程</span></span><br><span class="line">    <span class="type">Worker</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建工作线程，将任务传到Worker中</span></span><br><span class="line">        w = <span class="keyword">new</span> <span class="title class_">Worker</span>(firstTask);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> w.thread;</span><br><span class="line">        <span class="comment">// 只有你写的线程工厂返回的是null，这里才会为null</span></span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取锁资源</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">            <span class="comment">// 加锁。  因为我要在启动这个工作线程时，避免线程池状态发生变化，加锁。</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 重新获取ctl，拿到线程池状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">// DCL i think you know~~~</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="literal">null</span>)) &#123;</span><br><span class="line">                   	<span class="comment">// 判断Worker中的thread是否已经启动了，一般不会启动，除非你在线程工厂把他启动了</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) </span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalThreadStateException</span>();</span><br><span class="line">                    <span class="comment">// 将工作线程存储到hashSet中</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">// 获取工作线程个数，判断是否需要修改最大工作线程数记录。</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 工作线程添加成功     0</span></span><br><span class="line">                    workerAdded = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果添加成功</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动工作线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">// 设置标识为true</span></span><br><span class="line">                workerStarted = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果工作线程启动失败</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果添加工作线程失败，执行</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addWorkerFailed</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 说明worker可能存放到了workers的hashSet中。</span></span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 移除！</span></span><br><span class="line">            workers.remove(w);</span><br><span class="line">        <span class="comment">// 减掉workerCount的数值 -1</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line">        <span class="comment">// 尝试干掉自己</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、runWorker执行任务"><a href="#五、runWorker执行任务" class="headerlink" title="五、runWorker执行任务"></a>五、runWorker执行任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(Worker w)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到当前线程对象</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到worker中存放的Runnable</span></span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> w.firstTask;</span><br><span class="line">    <span class="comment">// 将worker中的任务清空</span></span><br><span class="line">    w.firstTask = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 揍是一个标识</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">completedAbruptly</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果Worker自身携带任务，直接执行</span></span><br><span class="line">        <span class="comment">// 如果Worker携带的是null，通过getTask去工作队列获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = getTask()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 判断线程池状态是否大于等于STOP，如果是要中断当前线程</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 <span class="comment">// 中断当前线程（DCL）</span></span><br><span class="line">                 (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">  </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 前置钩子</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">thrown</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 后置钩子</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 当前工作执行完一个任务，就++</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、getTask工作线程排队拿任务"><a href="#六、getTask工作线程排队拿任务" class="headerlink" title="六、getTask工作线程排队拿任务"></a>六、getTask工作线程排队拿任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable <span class="title function_">getTask</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 超时-false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">timedOut</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 阿巴</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 线程池状态判断</span></span><br><span class="line">        <span class="comment">// 如果线程池状态为SHUTDOWN &amp;&amp; 工作队列为空</span></span><br><span class="line">        <span class="comment">// 如果线程池状态为STOP</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 对工作线程个数--</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数量的判断。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断核心线程是否允许超时？</span></span><br><span class="line">        <span class="comment">// 工作线程个数是否大于核心线程数</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">timed</span> <span class="operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断工作线程是否超过了最大线程数 &amp;&amp; 工作队列为null</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">// 工作线程数有问题，必须-1，干掉当前工作线程</span></span><br><span class="line">            <span class="comment">// 工作线程是否超过了核心线程，如果超时，就干掉当前线程</span></span><br><span class="line">            <span class="comment">// 对工作线程个数--</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是非核心，走poll，拉取工作队列任务，</span></span><br><span class="line">            <span class="comment">// 如果是核心线程，走take一直阻塞，拉取工作队列任务</span></span><br><span class="line">            <span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">            	<span class="comment">// 当工作队列没有任务时，这时就会被Condition通过await阻塞线程</span></span><br><span class="line">            	<span class="comment">// 当有任务添加到工作线程后，这是添加完任务后，就会用过Condition.signal唤醒阻塞的线程</span></span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            <span class="comment">// 执行的poll方法，并且在指定时间没拿到任务，</span></span><br><span class="line">            timedOut = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、processWorkerExit工作线程告辞"><a href="#七、processWorkerExit工作线程告辞" class="headerlink" title="七、processWorkerExit工作线程告辞~"></a>七、processWorkerExit工作线程告辞~</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processWorkerExit</span><span class="params">(Worker w, <span class="type">boolean</span> completedAbruptly)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是不正常操作，需要先对工作线程数-- （如果正常情况，getTask就--了）</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) </span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将当前工作线程完整的任务个数赋值给整个线程池中的任务数</span></span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        <span class="comment">// 干掉当前工作线程</span></span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 线程池是否可以中止，线程池状态是否发生变化。</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> ctl.get();</span><br><span class="line">    <span class="comment">//如果当前线程池状态小于STOP</span></span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="comment">// 判断线程池中的工作队列是否还有任务，并且工作线程是否还在。</span></span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 添加非核心空任务的线程处理工作队列中的任务</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拒绝策略：线程池提供的拒绝策略，一般不适合你的业务场景时，你就自己定义即可。</p>
<ul>
<li>AbortPolicy：抛出异常！</li>
<li>CallerRunsPolicy：让提交任务的线程处理这个任务！</li>
<li>DiscardPolicy：啥也不做，任务没了！</li>
<li>DiscardOldestPolicy：扔掉队列最前面的任务，尝试把当前任务添加进去！</li>
</ul>
<p>任务处理流程：</p>
<p>主线程执行execute添加任务，线程池创建工作线程，执行任务，执行任务，再次拉取工作队列任务，直到工作队列没有任务，阻塞工作线程</p>
<p>工作线程阻塞在工作队列，主线程执行execute添加任务到工作队列，工作线程被唤醒，拿到工作队列中的任务执行，执行完毕，再次拉取工作队列任务，直到工作队列没有任务，阻塞工作线程</p>
<h1 id="五、ConcurrentHashMap源码分析（一）"><a href="#五、ConcurrentHashMap源码分析（一）" class="headerlink" title="五、ConcurrentHashMap源码分析（一）"></a>五、<strong>ConcurrentHashMap源码分析（一）</strong></h1><h3 id="一、结构介绍"><a href="#一、结构介绍" class="headerlink" title="一、结构介绍"></a>一、结构介绍</h3><p>HashMap和ConcurrentHashMap的存储结构是一致的。</p>
<p>ConcurrentHashMap是线程安全的。</p>
<p>存储结构</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/23f3b048e86e409d8575949d06d450a3.png" alt="image.png"></p>
<p>关于put和putIfAbsent的区别</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put和putIfAbsent都是想ConcurrentHashMap中存储值。</span></span><br><span class="line"><span class="comment">// 如果出现key一致的，将新数据覆盖老数据，并且返回老数据</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果出现key一致的，什么都不做，返回老数据。 最只有key不存在时，才会正常的添加数据</span></span><br><span class="line"><span class="keyword">public</span> V <span class="title function_">putIfAbsent</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、散列算法"><a href="#二、散列算法" class="headerlink" title="二、散列算法"></a>二、散列算法</h3><p>散列算法是为了让hashCode的高16位参与到索引位置的计算中，从而尽可能的打散数据存放到数组上。从而减少Hash冲突<br>ConcurrentHashMap中，还会将hash值对HASH_BITS进行&amp;运算，让hash值一定是一个正数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ConcurrentHashMap存储数据的核心方法</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// key和value不能为null。              HashMap中是允许为null的。</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || value == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 散列算法就是基于key进行hash运算，并且根据散列算法的结果，确定当前key-value存储到数组的哪个索引位置。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> spread(key.hashCode());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列算法</span></span><br><span class="line"><span class="comment">// 散列算法是为了让hashCode的高16位参与到索引位置的计算中，从而尽可能的打散数据存放到数组上。从而减少Hash冲突</span></span><br><span class="line"><span class="comment">// ConcurrentHashMap中，还会将hash值对HASH_BITS进行&amp;运算，让hash值一定是一个正数。</span></span><br><span class="line"><span class="comment">// 因为ConcurrentHashMap中数组上的数据的hash值，如果为负数，有特殊含义</span></span><br><span class="line"><span class="comment">// static final int MOVED     = -1; // 代表当前位置数据在扩容，并且数据已经迁移到了新数组</span></span><br><span class="line"><span class="comment">// static final int TREEBIN   = -2; // 代表当前索引位置下，是一个红黑树。   转红黑树，TreeBin有参构造</span></span><br><span class="line"><span class="comment">// static final int RESERVED  = -3; // 代表当前索引位置已经被占了，但是值还没放进去呢。  compute方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">spread</span><span class="params">(<span class="type">int</span> h)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>))  &amp; HASH_BITS;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="number">00011000</span> <span class="number">00000110</span> <span class="number">00111000</span> <span class="number">00001100</span>  h</span><br><span class="line">^</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00011000</span> <span class="number">00000110</span>  h &gt;&gt;&gt; <span class="number">16</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">00011000</span> <span class="number">00000110</span> <span class="number">00111000</span> <span class="number">00001100</span> </span><br><span class="line">&amp;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span> <span class="number">11111111</span>  <span class="number">2048</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ConcurrentHashMap是如何根据hash值，计算存储的位置？</span><br><span class="line">(数组长度 - <span class="number">1</span>) &amp;  (h ^ (h &gt;&gt;&gt; <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">00011000</span> <span class="number">00000110</span> <span class="number">00110000</span> <span class="number">00001100</span>  key1-hash</span><br><span class="line"><span class="number">00011000</span> <span class="number">00000110</span> <span class="number">00111000</span> <span class="number">00001100</span>  key2-hash</span><br><span class="line">&amp;</span><br><span class="line"><span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000111</span> <span class="number">11111111</span>  <span class="number">2048</span> - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三、初始化数组"><a href="#三、初始化数组" class="headerlink" title="三、初始化数组"></a>三、初始化数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;  </span><br><span class="line">    <span class="comment">// 死循环~~~~</span></span><br><span class="line">    <span class="comment">// tab是ConcurrentHashMap的数组</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// 一堆变量</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 代表当前数组没有初始化。</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 初始化数组  （ConcurrentHashMap在new时，不会创建数组，在使用时，才会创建）</span></span><br><span class="line">            tab = initTable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sizeCtl是标识数组初始化和扩容的标识信息。</span></span><br><span class="line"><span class="comment">= -1：代表正在初始化！</span></span><br><span class="line"><span class="comment">&lt; -1：代表正在扩容！</span></span><br><span class="line"><span class="comment">= 0：代表没有初始化！</span></span><br><span class="line"><span class="comment">&gt; 0：①当前数组没有初始化，这个值，就代表初始化的长度！  ②如果已经初始化了，就代表下次扩容的阈值！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化数组操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    <span class="comment">// 声明tab：临时存数组。 sc：临时存sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// 判断数组还没初始化呢吧？</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// sc赋值，并判断是否小于0</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 线程先让出CPU的执行权。</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>(); </span><br><span class="line">        <span class="comment">// 如果sc大于等于0，没人在执行初始化操作。</span></span><br><span class="line">        <span class="comment">// 以CAS的方式，将sizeCtl，改为-1，代表当前线程正在执行初始化逻辑</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 判断数组还没初始化呢吧？  DCL</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 拿到数组的初始化长度</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    <span class="comment">// 创建数组</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                    <span class="comment">// 依次给局部变量和成员变量赋值。</span></span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// 计算下次扩容的阈值</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 将扩容阈值赋值给sizeCtl</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、添加数据-数组"><a href="#四、添加数据-数组" class="headerlink" title="四、添加数据-数组"></a>四、添加数据-数组</h3><p>数据添加到数组上（没有hash冲突）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// n： 数组长度。 i：索引位置。  f：i位置的数据。 fh：是f的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// tabAt(数组，索引位置) = 拿到数组指定索引位置的数据</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前索引位置数据为null。</span></span><br><span class="line">            <span class="comment">// 以CAS的方式，将数据放到tab的i位置上，将hash，key，value封装成了一个Node对象</span></span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>,<span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明当前位置数据已经被迁移到了新数组。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 帮你扩容，快点扩容完，我好把数据放到新数组~~~</span></span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、添加数据-链表"><a href="#五、添加数据-链表" class="headerlink" title="五、添加数据-链表"></a>五、添加数据-链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(K key, V value, <span class="type">boolean</span> onlyIfAbsent)</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到binCount</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        <span class="comment">// n： 数组长度。 i：索引位置。  f：i位置的数据。 fh：是f的hash值</span></span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 到这，说明出现了hash冲突，i位置有数据，尝试往i位置下挂数据</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 声明oldVal，返回结果</span></span><br><span class="line">            <span class="type">V</span> <span class="variable">oldVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 以桶位置数据作为锁，锁住当前桶，锁粒度更细。</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 再判断一次，数据没有变化，正常挂链表。</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="comment">// 链表添加操作</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// binCount赋值1，记录链表中Node的长度</span></span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// e：暂时指向数组位置数据</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">// 拿到当前数据的hash值，和数组位置数据的hash值比较，</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                <span class="comment">// 如果相等 , 判断 == 或者 equals 返回true</span></span><br><span class="line">                                ((ek = e.key) == key || (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                <span class="comment">// 尝试覆盖原数据，先获取老数据</span></span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="comment">// 如果是put方法，进去覆盖值</span></span><br><span class="line">                                <span class="comment">// 如果是putIfAbsent，进去不if逻辑</span></span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    <span class="comment">// 覆盖值</span></span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// pred暂存e</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="comment">// e指向下一个节点，并且如果e == null，说明下面没节点了</span></span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                                <span class="comment">// 将当前的值封装为Node对象，并挂在最后一个节点的后面</span></span><br><span class="line">                                pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树添加套路</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 省略部分代码</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果binCount != 0</span></span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果binCount &gt;= 8</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    <span class="comment">// 判断是扩容还是转红黑树</span></span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="comment">// 判断是否需要返回</span></span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、触发扩容"><a href="#六、触发扩容" class="headerlink" title="六、触发扩容"></a>六、触发扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是否需要转红黑树或者是扩容  tab：数组！  index：索引位置！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">    <span class="comment">// n：数组长度， sc：sizeCtl</span></span><br><span class="line">    Node&lt;K,V&gt; b; <span class="type">int</span> n, sc;</span><br><span class="line">    <span class="comment">// 判断tab不为null</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组长度 小于 64，不转红黑树，先扩容（更希望数据存放在数组上，O1）</span></span><br><span class="line">        <span class="comment">// 只有数组长度大于等于64并且链表长度达到8，才转为红黑树</span></span><br><span class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">            <span class="comment">// 扩容前的一些准备和业务判断</span></span><br><span class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 转红黑树操作</span></span><br><span class="line">        <span class="comment">// 将单向链表转换为TreeNode对象（双向链表），再通过TreeBin方法转为红黑树。</span></span><br><span class="line">        <span class="comment">// TreeBin中保留着双向链表以及红黑树！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="literal">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 省略部分代码~~</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="七、HashMap的扩容"><a href="#七、HashMap的扩容" class="headerlink" title="七、HashMap的扩容"></a>七、HashMap的扩容</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/10da615f655742e8b7fe3b357adff924.png" alt="image.png"></p>
<h1 id="六、ConcurrentHashMap扩容"><a href="#六、ConcurrentHashMap扩容" class="headerlink" title="六、ConcurrentHashMap扩容"></a>六、<strong><em>ConcurrentHashMap扩容</em></strong></h1><p>三种触发方式</p>
<p>达到了扩容的阈值</p>
<h3 id="一、tryPreSize方法-初始化数组"><a href="#一、tryPreSize方法-初始化数组" class="headerlink" title="一、tryPreSize方法-初始化数组"></a>一、tryPreSize方法-初始化数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容前操作，putAll，链表转红黑树  插入map的长度（putAll）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="comment">// 这个判断是给putAll留的，要计算当前数组的长度（初始化）</span></span><br><span class="line">    <span class="comment">// 如果size大于最大长度 / 2，直接将数组长度设置为最大值。</span></span><br><span class="line">    <span class="comment">// tableSizeFor，将长度设置的2的n次幂</span></span><br><span class="line">    <span class="comment">// c是初始化数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// sc是给sizeCtl赋值</span></span><br><span class="line">    <span class="comment">// -1:正在初始化数组，小于-1：正在扩容，0：代表还没初始化数组，大于0：可能初始化了(代表阈值)，也可能没初始化（初始化的长度）</span></span><br><span class="line">    <span class="type">int</span> sc;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 代表没有正在执行初始化，也没有正在执行扩容。、</span></span><br><span class="line">        <span class="comment">// tab：数组，n：数组长度</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">        <span class="comment">// 判断数组是不是还没初始化呢</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 初始化数组，和initTable一样的东西</span></span><br><span class="line">            <span class="comment">// 在sc和c之间选择最大值，作为数组的初始化长度</span></span><br><span class="line">            n = (sc &gt; c) ? sc : c;</span><br><span class="line">            <span class="comment">// 要初始化，就直接把sizeCtl设置为-1，代表我要初始化数组</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// DCL！</span></span><br><span class="line">                    <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                        <span class="comment">// 创建数组</span></span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n];</span><br><span class="line">                        <span class="comment">// 初始化数组赋值给成员变量</span></span><br><span class="line">                        table = nt;</span><br><span class="line">                        <span class="comment">// sc先设置成阈值</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 将sc赋值给sizeCtl</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 要么是c没有超过阈值，要么是超过最大值，啥事不做~~~</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 省略部分代码。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、tryPreSize方法-扩容标识戳"><a href="#二、tryPreSize方法-扩容标识戳" class="headerlink" title="二、tryPreSize方法-扩容标识戳"></a>二、tryPreSize方法-扩容标识戳</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容前操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">tryPresize</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 省略部分初始化代码</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab = table; <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 扩容前操作！</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">            <span class="comment">// 计算扩容标识戳（基于老数组长度计算扩容标识戳，因为ConcurrentHashMap允许多线程迁移数据。）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(n);</span><br><span class="line">            <span class="comment">// 这里是一个BUG，当前sc在while循环中，除了初始化没有额外赋值的前提下，这个sc &lt; 0 永远进不来。</span></span><br><span class="line">            <span class="comment">// 虽然是BUG，但是清楚sc &lt; 0 代表正在扩容</span></span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                Node&lt;K,V&gt;[] nt;    <span class="number">31</span> ~ <span class="number">16</span>   <span class="number">15</span> ~ <span class="number">0</span></span><br><span class="line">                <span class="comment">// 这里是第二个BUG</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs ||   <span class="comment">// 判断协助扩容线程的标识戳是否一致</span></span><br><span class="line">                    sc == rs &lt;&lt; RESIZE_STAMP_SHIFT + <span class="number">1</span> ||    <span class="comment">// BUG之一,在判断扩容操作是否已经到了最后的检查阶段</span></span><br><span class="line">                    sc == rs &lt;&lt; RESIZE_STAMP_SHIFT + MAX_RESIZERS ||   <span class="comment">// BUG之一，判断扩容线程是否已经达到最大值</span></span><br><span class="line">                    (nt = nextTable) == <span class="literal">null</span> ||  <span class="comment">// 新数组为null，说明也已经扩容完毕，扩容完毕后，才会把nextTable置位null</span></span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>) <span class="comment">// transferIndex为线程领取任务的最大节点，如果为0，代表所有老数据迁移任务都没领干净了</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还没有执行扩容，当前线程可能是第一个进来执行扩容的线程</span></span><br><span class="line">            <span class="comment">// 基于CAS的方式，将sizeCtl从原值改为 扩容标识戳左移16位</span></span><br><span class="line">            <span class="comment">// 10000000 00011010 00000000 00000010  一定是&lt; -1的负数，可以代表当前ConcurrentHashMap正在扩容</span></span><br><span class="line">            <span class="comment">// 为什么是低位+2，代表1个线程扩容。 低位为5，就代表4个线程正在并发扩容</span></span><br><span class="line">            <span class="comment">// 扩容分为2部：创建新数组，迁移数据。</span></span><br><span class="line">            <span class="comment">// 当最后一个线程迁移完毕数据后，对低位-1.最终结果低位还是1，需要对整个老数组再次检查，数据是否迁移干净</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                <span class="comment">// 开始扩容操作，传入老数组~~</span></span><br><span class="line">                transfer(tab, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">resizeStamp</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 32~64</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000000 00011010</span></span><br><span class="line">    <span class="comment">// 计算n在二进制表示时，前面有多少个0</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 10000000 00000000</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 10000000 00011010</span></span><br><span class="line">    <span class="comment">// 前面的操作是基于数组长度等到一个标识，方便其他线程参与扩容</span></span><br><span class="line">    <span class="comment">// 后面的值是为了保证当前扩容戳左移16位之后，一定是一个负数</span></span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三、transfer方法-构建新数组"><a href="#三、transfer方法-构建新数组" class="headerlink" title="三、transfer方法-构建新数组"></a>三、transfer方法-构建新数组</h3><p>transfer方法：</p>
<ul>
<li>计算步长</li>
<li>初始化新数组</li>
<li>线程领取迁移数据任务</li>
<li>判断迁移是否完成，并判断当前线程是否是最后一个完成的</li>
<li>查看当前位置数据是否为null</li>
<li>查看当前位置数据是否为fwd</li>
<li>链表迁移数据-lastRun机制</li>
<li>红黑树迁移-迁移完数据长度小于等于6，转回链表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩容操作，以第一个进来执行扩容的线程为例。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建新数组流程！</span></span><br><span class="line">    <span class="comment">// n：老数组长度32，   stride：扩容的步长16</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tab.length, stride;</span><br><span class="line">    <span class="comment">// NCPU:4</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000000 00000000</span></span><br><span class="line">    <span class="comment">// 00000000 00000000 00000100 00000000  - 1024 512 256 128 / 4 = 32</span></span><br><span class="line">    <span class="comment">// 如果每个线程迁移的长度基于CPU计算，大于16，就采用计算的值，如果小于16，就用16</span></span><br><span class="line">    <span class="comment">// 每个线程每次最小迁移16长度数据</span></span><br><span class="line">    <span class="comment">// stride = 1 &lt; 16</span></span><br><span class="line">    <span class="comment">// 这个操作就是为了充分发挥CPU性能，因为迁移数据是CPU密集型操作，尽量让并发扩容线程数量不要太大，从而造成CPU的性能都消耗在了切换上，造成扩容效率降低</span></span><br><span class="line">    <span class="comment">// 如果要做优化的，推荐将扩容线程数设置为和CPU内核数+1一致。</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) </span><br><span class="line">        stride = MIN_TRANSFER_STRIDE; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新数组没有初始化</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="literal">null</span>) &#123;   </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 初始化数组</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 新数组赋值给nextTab</span></span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;   </span><br><span class="line">            <span class="comment">// 要么OOM，要么数组长度达到最大值。</span></span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将nextTable成员变量赋值</span></span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        <span class="comment">// transferIndex设置为老数组长度</span></span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// n：老数组长度</span></span><br><span class="line"><span class="comment">// stride：步长</span></span><br><span class="line"><span class="comment">// nextTale,nextTab：新数组</span></span><br><span class="line"><span class="comment">// transferIndex：线程领取任务时的核心属性</span></span><br></pre></td></tr></table></figure>
<h3 id="四、transfer方法-迁移数据"><a href="#四、transfer方法-迁移数据" class="headerlink" title="四、transfer方法-迁移数据"></a>四、transfer方法-迁移数据</h3><p>第一步，线程领取迁移数据的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// n：老数组长度   32</span></span><br><span class="line">    <span class="comment">// stride：步长   16</span></span><br><span class="line">    <span class="comment">// nextTale,nextTab：新数组</span></span><br><span class="line">    <span class="comment">// nextn：新数组长度  64 </span></span><br><span class="line">    <span class="comment">// transferIndex：线程领取任务时的核心属性 32</span></span><br><span class="line">    <span class="comment">// 先看领取任务的过程！！！</span></span><br><span class="line">    <span class="comment">// 声明fwd节点，在老数组迁移数据完成后，将fwd赋值上去</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 领任务的核心标识</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 扩容结束了咩？</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 扩容的for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="comment">// 领取任务的while循环</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 第一个判断是为了迁移下一个索引数据（暂时不管）</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 说明没有任务可以领取了（暂时不管）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// transferIndex：16</span></span><br><span class="line">            <span class="comment">// stride：16，nextIndex：32，nextBound：16</span></span><br><span class="line">            <span class="comment">// bound：16，i：31</span></span><br><span class="line">            <span class="comment">// 开始领取任务，如果CAS成功，代表当前线程领取了32~16这个范围数据的迁移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>第二步：判断是否结束，以及线程退出扩容，并且为空时，设置fwd，并且hash为moved直接移动到下个位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// n：老数组长度   32</span></span><br><span class="line">    <span class="comment">// stride：步长   16</span></span><br><span class="line">    <span class="comment">// nextTale,nextTab：新数组</span></span><br><span class="line">    <span class="comment">// nextn：新数组长度  64 </span></span><br><span class="line">    <span class="comment">// transferIndex：线程领取任务时的核心属性 32</span></span><br><span class="line">    <span class="comment">// 先看领取任务的过程！！！</span></span><br><span class="line">    <span class="comment">// 声明fwd节点，在老数组迁移数据完成后，将fwd赋值上去</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 领任务的核心标识</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 扩容结束了咩？</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 扩容的for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="comment">// 领取任务的while循环</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 第一个判断是为了迁移下一个索引数据（暂时不管）</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 说明没有任务可以领取了（暂时不管）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// transferIndex：16</span></span><br><span class="line">            <span class="comment">// stride：16，nextIndex：32，nextBound：16</span></span><br><span class="line">            <span class="comment">// bound：16，i：31</span></span><br><span class="line">            <span class="comment">// 开始领取任务，如果CAS成功，代表当前线程领取了32~16这个范围数据的迁移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迁移最后一段的线程干完活了，或者其他线程没有任务可以领取了。</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">// 判断结束了没，第一次肯定进不来</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 结束扩容，将nextTabl设置为null</span></span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 将迁移完数据的新数组，指向指向的老数组</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 将sizeCtl复制为下次扩容的阈值</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这，说明当前线程没有任务可以领取了</span></span><br><span class="line">            <span class="comment">// 基于CAS的方式，将低位-1，代表当前线程退出扩容操作（如果是最后一个，还有一个额外的活）</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 判断我是否是最后一个完成迁移数据的线程，如果不是，直接return结束</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 如果到这，说明我是最后一个结束迁移数据的线程。</span></span><br><span class="line">                <span class="comment">// finishing结束表示和advance领取任务的标识全部设置为true</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// i设置为老数组长度，从头到位再检查一次整个老数组。</span></span><br><span class="line">                i = n; </span><br><span class="line">            &#125;</span><br><span class="line">            额外分析：当前线程完成领取的迁移任务后，再次进入<span class="keyword">while</span>循环，查看是否有任务可以领取如果transferIndex变为<span class="number">0</span>了，代表我没有任务可以领取，将i设置为-<span class="number">1</span>没有任务可以领取，退出当前扩容操作：<span class="number">1</span>、基于CAS将sizeCtl - <span class="number">1</span>代表我退出扩容操作<span class="number">2</span>、-<span class="number">1</span>成功后，还要判断，我是不是最后一个退出扩容的线程（sc - <span class="number">2</span>值是否是 扩容标识戳 &lt;&lt; <span class="number">16</span>）    如果不是，直接<span class="keyword">return</span>结束<span class="number">3</span>、如果是最后一个结束迁移的线程，将i复制为老数组长度，重新从末位到头部再次检查一圈</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 如果发现迁移为主的数据为null，设置放置一个fwd，代表当前位置迁移完成</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 是在检查时的逻辑</span></span><br><span class="line">            advance = <span class="literal">true</span>; </span><br></pre></td></tr></table></figure>
<h3 id="五、transfer方法-lastRun机制"><a href="#五、transfer方法-lastRun机制" class="headerlink" title="五、transfer方法-lastRun机制"></a>五、transfer方法-lastRun机制</h3><p>就是迁移链表到新数组时的操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> &#123;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">    <span class="comment">// n：老数组长度   32</span></span><br><span class="line">    <span class="comment">// stride：步长   16</span></span><br><span class="line">    <span class="comment">// nextTale,nextTab：新数组</span></span><br><span class="line">    <span class="comment">// nextn：新数组长度  64 </span></span><br><span class="line">    <span class="comment">// transferIndex：线程领取任务时的核心属性 32</span></span><br><span class="line">    <span class="comment">// 先看领取任务的过程！！！</span></span><br><span class="line">    <span class="comment">// 声明fwd节点，在老数组迁移数据完成后，将fwd赋值上去</span></span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="comment">// 领任务的核心标识</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">advance</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 扩容结束了咩？</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">finishing</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 扩容的for循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="type">int</span> fh;</span><br><span class="line">        <span class="comment">// 领取任务的while循环</span></span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="type">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="comment">// 第一个判断是为了迁移下一个索引数据（暂时不管）</span></span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 说明没有任务可以领取了（暂时不管）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// transferIndex：16</span></span><br><span class="line">            <span class="comment">// stride：16，nextIndex：32，nextBound：16</span></span><br><span class="line">            <span class="comment">// bound：16，i：31</span></span><br><span class="line">            <span class="comment">// 开始领取任务，如果CAS成功，代表当前线程领取了32~16这个范围数据的迁移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="built_in">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迁移最后一段的线程干完活了，或者其他线程没有任务可以领取了。</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> sc;</span><br><span class="line">            <span class="comment">// 判断结束了没，第一次肯定进不来</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                <span class="comment">// 结束扩容，将nextTabl设置为null</span></span><br><span class="line">                nextTable = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 将迁移完数据的新数组，指向指向的老数组</span></span><br><span class="line">                table = nextTab;</span><br><span class="line">                <span class="comment">// 将sizeCtl复制为下次扩容的阈值</span></span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// 结束</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 到这，说明当前线程没有任务可以领取了</span></span><br><span class="line">            <span class="comment">// 基于CAS的方式，将低位-1，代表当前线程退出扩容操作（如果是最后一个，还有一个额外的活）</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 判断我是否是最后一个完成迁移数据的线程，如果不是，直接return结束</span></span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">// 如果到这，说明我是最后一个结束迁移数据的线程。</span></span><br><span class="line">                <span class="comment">// finishing结束表示和advance领取任务的标识全部设置为true</span></span><br><span class="line">                finishing = advance = <span class="literal">true</span>;</span><br><span class="line">                <span class="comment">// i设置为老数组长度，从头到位再检查一次整个老数组。</span></span><br><span class="line">                i = n; </span><br><span class="line">            &#125;</span><br><span class="line">            额外分析：当前线程完成领取的迁移任务后，再次进入<span class="keyword">while</span>循环，查看是否有任务可以领取如果transferIndex变为<span class="number">0</span>了，代表我没有任务可以领取，将i设置为-<span class="number">1</span>没有任务可以领取，退出当前扩容操作：<span class="number">1</span>、基于CAS将sizeCtl - <span class="number">1</span>代表我退出扩容操作<span class="number">2</span>、-<span class="number">1</span>成功后，还要判断，我是不是最后一个退出扩容的线程（sc - <span class="number">2</span>值是否是 扩容标识戳 &lt;&lt; <span class="number">16</span>）    如果不是，直接<span class="keyword">return</span>结束<span class="number">3</span>、如果是最后一个结束迁移的线程，将i复制为老数组长度，重新从末位到头部再次检查一圈</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 如果发现迁移为主的数据为null，设置放置一个fwd，代表当前位置迁移完成</span></span><br><span class="line">            advance = casTabAt(tab, i, <span class="literal">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            <span class="comment">// 是在检查时的逻辑</span></span><br><span class="line">            advance = <span class="literal">true</span>; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 迁移数据，加锁！</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="comment">// 拿到当前位置数据</span></span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="comment">// 说明当前节点状态正常，不是迁移，不是红黑树，不是预留</span></span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// fh与老数组进行&amp;运算，得到runBit</span></span><br><span class="line">                        <span class="comment">// 00001111</span></span><br><span class="line">                        <span class="comment">// 00010000</span></span><br><span class="line">                        <span class="comment">// 这个计算的结果，会决定当前数据在迁移时，是放到新数组的i位置还有新数组的 i + n位置</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">runBit</span> <span class="operator">=</span> fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="comment">// lastRun机制</span></span><br><span class="line">                        <span class="comment">// 提前循环一次链表，将节点赋值到对应的高低位Node./</span></span><br><span class="line">                        <span class="comment">// 如果链表最后面的值没有变化，那就不动指针，直接复制。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="literal">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="literal">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 再次循环时，就循环到lastRun位置，不再继续往下循环</span></span><br><span class="line">                        <span class="comment">// 这样可以不用每个节点都new，避免GC和OOM问题。</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="type">int</span> <span class="variable">ph</span> <span class="operator">=</span> p.hash; <span class="type">K</span> <span class="variable">pk</span> <span class="operator">=</span> p.key; <span class="type">V</span> <span class="variable">pv</span> <span class="operator">=</span> p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 放低位</span></span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        <span class="comment">// 放高位</span></span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        <span class="comment">// 将当前迁移完的桶位置，设置上fwd，代表数据迁移完毕</span></span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        <span class="comment">// advance，代表执行下次循环，i--。</span></span><br><span class="line">                        advance = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 省略红黑树迁移！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="六、helpTransfer方法-协助扩容"><a href="#六、helpTransfer方法-协助扩容" class="headerlink" title="六、helpTransfer方法-协助扩容"></a>六、helpTransfer方法-协助扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 协助扩容</span></span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] nextTab; <span class="type">int</span> sc;</span><br><span class="line">    <span class="comment">// 老数组不为null，当前节点是fwd，新数组不为null</span></span><br><span class="line">    <span class="keyword">if</span> (tab != <span class="literal">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建自己的扩容标识戳</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> resizeStamp(tab.length);</span><br><span class="line">        <span class="comment">// 判断之前赋值的内容是否有变化，并且sizeCtl是否小于0</span></span><br><span class="line">        <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">               (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || </span><br><span class="line">                sc == rs + <span class="number">1</span> ||</span><br><span class="line">                sc == rs + MAX_RESIZERS || </span><br><span class="line">                transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 有一个满足，就说明不需要协助扩容了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// CAS，将sizeCtl + 1，代表来协助扩容了</span></span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                transfer(tab, nextTab);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="七、JUC并发工具"><a href="#七、JUC并发工具" class="headerlink" title="七、JUC并发工具"></a>七、<strong>JUC并发工具</strong></h1><p>跟着我掌握这些内容，首先你要对AQS有一定了解。（ReentrantLock，ReentrantReadWriteLock）</p>
<h3 id="一、CountDownLatch应用"><a href="#一、CountDownLatch应用" class="headerlink" title="一、CountDownLatch应用"></a>一、CountDownLatch应用</h3><p>CountDownLatch本身就好像一个计数器，可以让一个线程或多个线程等待其他线程完成后再执行。</p>
<p>应用方式巨简单</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="comment">// 声明CountDownLatch，有参构造传入的值，会赋值给state，CountDownLatch基于AQS实现</span></span><br><span class="line">    <span class="comment">// 3 - 1 = 2 - 1 = 1 - 1</span></span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">countDownLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;111&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;222&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;333&quot;</span>);</span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主线会阻塞在这个位置，直到CountDownLatch的state变为0</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、CountDownLatch核心源码分析"><a href="#二、CountDownLatch核心源码分析" class="headerlink" title="二、CountDownLatch核心源码分析"></a>二、CountDownLatch核心源码分析</h3><h4 id="2-1-从构造方法查看"><a href="#2-1-从构造方法查看" class="headerlink" title="2.1 从构造方法查看"></a>2.1 从构造方法查看</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountDownLatch 的有参构造</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CountDownLatch</span><span class="params">(<span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="comment">// 健壮性校验</span></span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;count &lt; 0&quot;</span>);</span><br><span class="line">    <span class="comment">// 构建Sync给AQS的state赋值</span></span><br><span class="line">    <span class="built_in">this</span>.sync = <span class="keyword">new</span> <span class="title class_">Sync</span>(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-countDown方法"><a href="#2-2-countDown方法" class="headerlink" title="2.2 countDown方法"></a>2.2 countDown方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// countDown方法,本质就是调用了AQS的释放共享锁操作</span></span><br><span class="line"><span class="comment">// 这里的功能都是AQS提供的，只有tryReleaseShared需要实现的类自己去编写业务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒在AQS队列中排队的线程。</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// countDownLatch实现的业务</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// state - 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 用CAS赋值</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果CountDownLatch中的state已经为0了，那么再次执行countDown跟没执行一样。</span></span><br><span class="line"><span class="comment">// 而且只要state变为0，await就不会阻塞线程。</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-await方法"><a href="#2-3-await方法" class="headerlink" title="2.3 await方法"></a>2.3 await方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// await方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 调用了AQS提供的获取共享锁并且允许中断的方法</span></span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AQS提欧的获取共享锁并且允许中断的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// countDownLatch操作</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 如果返回的是-1，代表state肯定大于0</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CountDownLatch实现的tryAcquireShared</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="comment">// state为0，返回1,。否则返回-1</span></span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让当前线程进到AQS队列，排队去</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 将当前线程封装为Node，并且添加到AQS的队列中</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次走上面的tryAcquireShared，如果返回的是的1，代表state为0</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 会将当前线程和后面所有排队的线程都唤醒。</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三、Semaphore应用"><a href="#三、Semaphore应用" class="headerlink" title="三、Semaphore应用"></a>三、Semaphore应用</h3><p>也是常用的JUC并发工具，一般用于流控。比如有一个公共资源，多线程都可以访问时，可以用信号量做限制。</p>
<p>连接池，内部的链接对象有限，每当有一个线程获取连接对象时，对信号量-1，当这个线程归还资源时对信号量+1。</p>
<p>如果线程拿资源时，发现Semaphore内部的资源个数为0，就会被阻塞。</p>
<p>Hystrix的隔离策略 - 线程池，信号量</p>
<p>使用方式巨简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="comment">// 声明信号量</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 能否去拿资源</span></span><br><span class="line">    semaphore.acquire();</span><br><span class="line">    <span class="comment">// 拿资源处理业务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main&quot;</span>);</span><br><span class="line">    <span class="comment">// 归还资源</span></span><br><span class="line">    semaphore.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、Semaphore核心源码分析"><a href="#四、Semaphore核心源码分析" class="headerlink" title="四、Semaphore核心源码分析"></a>四、Semaphore核心源码分析</h3><h4 id="4-1-有参构造"><a href="#4-1-有参构造" class="headerlink" title="4.1 有参构造"></a>4.1 有参构造</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Semaphore有公平和非公平两种竞争资源的方式。</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Semaphore</span><span class="params">(<span class="type">int</span> <span class="keyword">permits</span>, <span class="type">boolean</span> fair)</span> &#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> <span class="title class_">FairSync</span>(<span class="keyword">permits</span>) : <span class="keyword">new</span> <span class="title class_">NonfairSync</span>(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置资源个数，State其实就是信号量的资源个数</span></span><br><span class="line">Sync(<span class="type">int</span> <span class="keyword">permits</span>) &#123;</span><br><span class="line">    setState(<span class="keyword">permits</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-acquire"><a href="#4-2-acquire" class="headerlink" title="4.2 acquire"></a>4.2 acquire</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阿巴阿巴~</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公平</span></span><br><span class="line"><span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">tryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 公平方式，先好看队列中有木有排队的，有排队的返回-1，执行doAcquireSharedInterruptibly去排队</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 那state</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// remaining = 资源数 - 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="comment">// 如果资源不够，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            <span class="comment">// 如果资源够，执行CAS，修改state</span></span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">nonfairTryAcquireShared</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">available</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="type">int</span> <span class="variable">remaining</span> <span class="operator">=</span> available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-release"><a href="#4-3-release" class="headerlink" title="4.3 release"></a>4.3 release</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个一起 阿巴阿巴</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 唤醒在AQS中排队的Node，去竞争资源</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号量实现的归还资源</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryReleaseShared</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿state</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="comment">// state + 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> current + releases;</span><br><span class="line">        <span class="comment">// 资源最大值，再+1，变为负数</span></span><br><span class="line">        <span class="keyword">if</span> (next &lt; current)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum permit count exceeded&quot;</span>);</span><br><span class="line">        <span class="comment">// CAS 改一手</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-4-分析AQS中PROPAGATE类型节点（唯一的难点）"><a href="#4-4-分析AQS中PROPAGATE类型节点（唯一的难点）" class="headerlink" title="4.4 分析AQS中PROPAGATE类型节点（唯一的难点）"></a>4.4 分析AQS中PROPAGATE类型节点（唯一的难点）</h4><p>JDK1.5中，使用信号量时，可能会造成在有资源的情况下，后继节点无法被唤醒。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/eb35e021971c45a1b54dbb440b1a7e20.png" alt="image.png"></p>
<p>在JDK1.8中，问题被修复，修复方式就是追加了PROPAGATE节点状态来解决。</p>
<p>共享锁在释放资源后，如果头节点为0，无法确认真的没有后继节点。如果头节点为0，需要将头节点的状态修改为-3，当最新拿到锁资源的线程，查看是否有后继节点并且为共享锁，就唤醒排队的线程</p>
<h3 id="五、CyclicBarrier应用"><a href="#五、CyclicBarrier应用" class="headerlink" title="五、CyclicBarrier应用"></a>五、CyclicBarrier应用</h3><p>一般称为栅栏，和CountDownLatch很像。</p>
<p>CountDownLatch在操作时，只能使用一次，也就是state变为0之后，就无法继续玩了。</p>
<p>CyclicBarrier是可以复用的，他的计数器可以归位，然后再处理。而且可以在计数过程中出现问题后，重置当前CyclicBarrier，再次重新操作！</p>
<p>应用一波</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException &#123;</span><br><span class="line">    <span class="comment">// 声明栅栏</span></span><br><span class="line">    <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">3</span>,() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打手枪！&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第一位选手到位&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;第一位往死里跑！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;第二位选手到位&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">            System.out.println(<span class="string">&quot;第二位也往死里跑！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;裁判已经到位&quot;</span>);</span><br><span class="line">    barrier.await();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="六、CyclicBarrier核心源码分析"><a href="#六、CyclicBarrier核心源码分析" class="headerlink" title="六、CyclicBarrier核心源码分析"></a>六、CyclicBarrier核心源码分析</h3><h4 id="6-1-有参构造"><a href="#6-1-有参构造" class="headerlink" title="6.1 有参构造"></a>6.1 有参构造</h4><p>CyclicBarrier没有直接使用AQS，而是使用ReentrantLock，简介的使用的AQS</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CyclicBarrier的有参</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">CyclicBarrier</span><span class="params">(<span class="type">int</span> parties, Runnable barrierAction)</span> &#123;、</span><br><span class="line">    <span class="comment">// 健壮性判断！</span></span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="comment">// parties是final修饰的，需要在重置时，使用！</span></span><br><span class="line">    <span class="built_in">this</span>.parties = parties;</span><br><span class="line">    <span class="comment">// count是在执行await用来计数的。</span></span><br><span class="line">    <span class="built_in">this</span>.count = parties;</span><br><span class="line">    <span class="comment">// 当计数count为0时 ，先执行这个Runnnable！在唤醒被阻塞的线程</span></span><br><span class="line">    <span class="built_in">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-await"><a href="#6-2-await" class="headerlink" title="6.2 await"></a>6.2 await</h4><p>线程执行await方法，会对count-1，再判断count是否为0</p>
<p>如果不为0，需要添加到AQS中的ConditionObject的Waiter队列中排队，并park当前线程</p>
<p>如果为0，证明线程到齐，需要执行nextGeneration，会先将Waiter队列中的Node全部转移到AQS的队列中，并且有后继节点的，ws设置为-1。没有后继节点设置为0。然后重置count和broker标记。等到unlock执行后，每个线程都会被唤醒。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选手到位！！！</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dowait</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException &#123;</span><br><span class="line">    <span class="comment">// 加锁？？  因为CyclicBarrier是基于ReentrantLock-Condition的await和singalAll方法实现的。</span></span><br><span class="line">    <span class="comment">// 相当于synchronized中使用wait和notify</span></span><br><span class="line">    <span class="comment">// 别忘了，只要挂起，会释放锁资源。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 里面就是boolean，默认false</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Generation</span> <span class="variable">g</span> <span class="operator">=</span> generation;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断之前栅栏加入线程时，是否有超时、中断等问题，如果有，设置boolean为true，其他线程再进来，直接凉凉</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对计数器count--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> --count;</span><br><span class="line">        <span class="comment">// 如果--完，是0，代表突破栅栏，干活！</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  </span><br><span class="line">            <span class="comment">// 默认false</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">ranAction</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果你用的是2个参数的有参构造，说明你传入了任务，index == 0，先执行CyclicBarrier有参的任务</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">Runnable</span> <span class="variable">command</span> <span class="operator">=</span> barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="literal">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                <span class="comment">// 设置为true</span></span><br><span class="line">                ranAction = <span class="literal">true</span>;</span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --完之后，index不是0，代表还需要等待其他线程</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果没设置超时时间。  await()</span></span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="comment">// 设置了超时时间。  await(1,SECOND)</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;</span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BrokenBarrierException</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TimeoutException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 挂起线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 允许中断</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 添加到队列（不是AQS队列，是AQS里的ConditionObject中的队列）</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">// 挂起当前线程</span></span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// count到0，唤醒所有队列里的线程线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">nextGeneration</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 这个方法就是将Waiter队列中的节点遍历都扔到AQS的队列中，真正唤醒的时机，是unlock方法</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// 重置计数器</span></span><br><span class="line">    count = parties;</span><br><span class="line">    <span class="comment">// 重置异常判断</span></span><br><span class="line">    generation = <span class="keyword">new</span> <span class="title class_">Generation</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="八、JUC阻塞队列"><a href="#八、JUC阻塞队列" class="headerlink" title="八、JUC阻塞队列"></a>八、<strong>JUC阻塞队列</strong></h1><p>阻塞队列：</p>
<ul>
<li>队列，先进先出的一个数据结构</li>
<li>阻塞，基于ReentrantLock实现的，并且线程的挂起也是通过Condition</li>
</ul>
<p>从最常用也是最简单的ArrayBlockingQueue，LinkedBlockingQueue</p>
<h3 id="一、ArrayBlockingQueue"><a href="#一、ArrayBlockingQueue" class="headerlink" title="一、ArrayBlockingQueue"></a>一、ArrayBlockingQueue</h3><p>ArrayBlockingQueue底层是采用数组实现的一个队列。因为底层是数据，一般被成为有界队列</p>
<p>其次阻塞方式，是基于ReentrantLock实现的。</p>
<p>常用的存取方法</p>
<h4 id="1-1-ArrayBlockingQueue应用"><a href="#1-1-ArrayBlockingQueue应用" class="headerlink" title="1.1 ArrayBlockingQueue应用"></a>1.1 ArrayBlockingQueue应用</h4><p>// 存数据操作  add(E),offer(E),put(E)，offer(E,time,unit)<br>// add(E)：添加数据到队列，如果满了，扔异常。<br>// offer(E)：添加数据到队列，如果满了，返回false<br>// put(E)：添加数据到队列，如果满了，线程挂起<br>// offer(E,time,unit)：添加数据到队列，如果满了，线程挂起一段时间</p>
<p>// 取数据操作  remove(),poll(),take(),poll(time,unit)<br>// remove()：从队列拿数据，拿到返回，拿到null，甩异常<br>// poll()：从队列拿数据，拿到返回，拿到null，也返回<br>// take()：从队列拿数据，拿到返回，没数据，一直阻塞<br>// poll(time,unit)：从队列拿数据，拿到返回，没数据，阻塞time时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, IOException &#123;</span><br><span class="line">    <span class="comment">// ArrayBlockingQueue,因为底层使用数组，必须要指定数组的长度，作为队列的长度</span></span><br><span class="line">    <span class="type">ArrayBlockingQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 存数据操作  add(E),offer(E),put(E)，offer(E,time,unit)</span></span><br><span class="line">    <span class="comment">// add(E)：添加数据到队列，如果满了，扔异常。</span></span><br><span class="line">    <span class="comment">// offer(E)：添加数据到队列，如果满了，返回false</span></span><br><span class="line">    <span class="comment">// put(E)：添加数据到队列，如果满了，线程挂起</span></span><br><span class="line">    <span class="comment">// offer(E,time,unit)：添加数据到队列，如果满了，线程挂起一段时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取数据操作  remove(),poll(),take(),poll(time,unit)</span></span><br><span class="line">    <span class="comment">// remove()：从队列拿数据，拿到返回，拿到null，甩异常</span></span><br><span class="line">    <span class="comment">// poll()：从队列拿数据，拿到返回，拿到null，也返回</span></span><br><span class="line">    <span class="comment">// take()：从队列拿数据，拿到返回，没数据，一直阻塞</span></span><br><span class="line">    <span class="comment">// poll(time,unit)：从队列拿数据，拿到返回，没数据，阻塞time时间</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-存数据源码"><a href="#1-2-存数据源码" class="headerlink" title="1.2 存数据源码"></a>1.2 存数据源码</h4><p>offer，添加时，先判断队列满了没，满了就返回false<br>offer(time,unit)，添加时，先判断队列满了没，满了先阻塞time时间，自动唤醒，还是满的，也返回false<br>put,添加时，先判断队列满了没，满了就阻塞，阻塞到被唤醒，或者被中断</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">// 存数据</span><br><span class="line">public boolean offer(E e) &#123;</span><br><span class="line">    // 非空校验</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    // 互斥锁</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        // 如果数组中的数据已经达到了数组的长度，没地儿了~，队列满了</span><br><span class="line">        if (count == items.length)</span><br><span class="line">            return false;</span><br><span class="line">        else &#123;</span><br><span class="line">            // 还有位置</span><br><span class="line">            enqueue(e);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 存放数据到数组中</span><br><span class="line">private void enqueue(E x) &#123;</span><br><span class="line">    // 拿到数组</span><br><span class="line">    final Object[] items = this.items;</span><br><span class="line">    // 数组放进去</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    // 把put指针++， 指针是否已经到了最后一个位置，归位到0位置。</span><br><span class="line">    if (++putIndex == items.length)</span><br><span class="line">        // 归位到0位置。</span><br><span class="line">        putIndex = 0;</span><br><span class="line">    // 数据条数 + 1</span><br><span class="line">    count++;</span><br><span class="line">    // 唤醒在阻塞的取数据线程</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// put方法</span><br><span class="line">public void put(E e) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// offer方法，可以阻塞一段时间</span><br><span class="line">public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    long nanos = unit.toNanos(timeout);</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    try &#123;</span><br><span class="line">        while (count == items.length) &#123;</span><br><span class="line">            if (nanos &lt;= 0)</span><br><span class="line">                return false;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(e);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">offer，添加时，先判断队列满了没，满了就返回false</span><br><span class="line">offer(time,unit)，添加时，先判断队列满了没，满了先阻塞time时间，自动唤醒，还是满的，也返回false</span><br><span class="line">put,添加时，先判断队列满了没，满了就阻塞，阻塞到被唤醒，或者被中断</span><br></pre></td></tr></table></figure>
<h4 id="1-3-取数据"><a href="#1-3-取数据" class="headerlink" title="1.3 取数据"></a>1.3 取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阿巴阿巴~~取数据</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// count == 0代表没数据， 就返回null，有数据走dequeue</span></span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="literal">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中那数据</span></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="built_in">this</span>.items;</span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) items[takeIndex];</span><br><span class="line">    <span class="comment">// 将取完的位置置位null</span></span><br><span class="line">    items[takeIndex] = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// take指针++，如果到头，归位0~~</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 数据条数 - 1</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="comment">// 唤醒队列满的时候，阻塞住的写线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();  <span class="comment">// 挂起线程，需要被唤醒</span></span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);   <span class="comment">//  挂起线程，到时间自动唤醒、或者被手动唤醒</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、LinkedBlockingQueue"><a href="#二、LinkedBlockingQueue" class="headerlink" title="二、LinkedBlockingQueue"></a>二、LinkedBlockingQueue</h3><p>底层基于链表实现的，会将每个元素封装为Node，Node有当前值，还有一个next指针，一般成为无界队列</p>
<p>LinkedBlockingQueue本质就是一个用Node封装的单向链表。</p>
<p>LinkedBlockingQueue内部提供了读锁和写锁，读写不互斥，而且记录数据条数的属性是Atomic原子类</p>
<p>核心属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 阻塞队列元素会被封装为Node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line"></span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 指定队列的长度，如果不传值，默认为Integer.MAX */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 记录数据条数 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 读锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 写锁 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> putLock.newCondition();</span><br></pre></td></tr></table></figure>
<h4 id="2-1-写操作"><a href="#2-1-写操作" class="headerlink" title="2.1 写操作"></a>2.1 写操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写操作~</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="comment">// 非空</span></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 拿到count（记录当前数据条数）</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 如果count达到了最大值</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == capacity)</span><br><span class="line">        <span class="comment">// 数据满了。</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 声明c </span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 将当前数据封装为Node</span></span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="comment">// 添加写锁~</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// ！！DCL！！</span></span><br><span class="line">        <span class="comment">// 再次拿到条数判断，如果还有空间，enqueue存数据</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &lt; capacity) &#123;</span><br><span class="line">            <span class="comment">// 数据放进来</span></span><br><span class="line">            enqueue(node);</span><br><span class="line">            <span class="comment">// 拿到count，再自增</span></span><br><span class="line">            c = count.getAndIncrement();</span><br><span class="line">            <span class="comment">// 添加完数据之后，长度依然小于最大长度，唤醒可能阻塞的写线程  </span></span><br><span class="line">            <span class="comment">// 读写不互斥，可能前面在执行时，队列是满的，但是读操作依然在进行</span></span><br><span class="line">            <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">                notFull.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// c == 0，说明添加数据之前，队列是空的，唤醒可能阻塞的读线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="comment">// 返回count &gt;= 0</span></span><br><span class="line">    <span class="keyword">return</span> c &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入数据到链表~~~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> &#123;</span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e, <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="built_in">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> <span class="title class_">Node</span>&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-读操作"><a href="#2-2-读操作" class="headerlink" title="2.2 读操作"></a>2.2 读操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="built_in">this</span>.count;</span><br><span class="line">    <span class="comment">// 为0，没数据，拜拜~~</span></span><br><span class="line">    <span class="keyword">if</span> (count.get() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 读锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="built_in">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果队列有数据  DCL</span></span><br><span class="line">        <span class="keyword">if</span> (count.get() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = dequeue();</span><br><span class="line">            <span class="comment">// count --</span></span><br><span class="line">            c = count.getAndDecrement();</span><br><span class="line">            <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// c &gt; 1,说明还有数据，唤醒读线程</span></span><br><span class="line">                notEmpty.signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        <span class="comment">// 到这说明还有位置呢，唤醒写线程</span></span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> first.item;</span><br><span class="line">    first.item = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、PriorityQueue"><a href="#三、PriorityQueue" class="headerlink" title="三、PriorityQueue"></a>三、PriorityQueue</h3><p>这个就是一个普通的队列，不是阻塞的。</p>
<p>因为DelayQueue和PriorityBlockingQueue都和PriorityQueue有关系，很类似。</p>
<p>先把PriorityQueue搞定，后续再看其他的优先级阻塞队列，效果更佳！</p>
<p>PriorityQueue才是真正而定无界队列。底层是数组实现，会扩容！</p>
<p>PriorityQueue实现优先级的方式，是基于二叉堆实现的</p>
<p>二叉堆：</p>
<ul>
<li>二叉堆是一颗完整的二叉树</li>
<li>任意一个节点大于父节点   或者   小于父节点</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/ae13aed05c654c478af5e7f64a25ec20.png" alt="image.png"></p>
<p>因为这个二叉堆是实现优先级队列的原理，那么队列或有添加和获取的操作，这种操作会影响二叉堆的结构，查看PriorityQueue队列的添加和获取操作如何保证结构</p>
<h4 id="3-1-添加操作上移保证结构"><a href="#3-1-添加操作上移保证结构" class="headerlink" title="3.1 添加操作上移保证结构"></a>3.1 添加操作上移保证结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先级队列添加操作，确定如何保证小顶堆结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// size是数组数据条数，大于等于数组长度后，需要扩容</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        <span class="comment">// Double size if small; else grow by 50%</span></span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// size + i，数据多一条</span></span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果i == 0，说明添加的是第一个数据</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 不是第一个数据，Up上移保证结构</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让当前节点和父节点比较，如果当前节点比较小，就上移~~~</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftUpUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> queue[parent];</span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-取数据如何保证二叉堆结构"><a href="#3-2-取数据如何保证二叉堆结构" class="headerlink" title="3.2 取数据如何保证二叉堆结构"></a>3.2 取数据如何保证二叉堆结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取堆顶数据</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 没有数据返回null</span></span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 最后一个数据的索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> --size;</span><br><span class="line">    <span class="comment">// 需要全都的数据</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) queue[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 取出最后一个数据</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) queue[s];</span><br><span class="line">    <span class="comment">// 将最后一个数据置位null</span></span><br><span class="line">    queue[s] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 下移保证安全</span></span><br><span class="line">        siftDown(<span class="number">0</span>, x);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 堆顶数据下移，知道last数据可以存放的位置，然后替换即可</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">siftDownUsingComparator</span><span class="params">(<span class="type">int</span> k, E x)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; half) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">child</span> <span class="operator">=</span> (k &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 找到左子</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">c</span> <span class="operator">=</span> queue[child];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> child + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; size &amp;&amp;</span><br><span class="line">            comparator.compare((E) c, (E) queue[right]) &gt; <span class="number">0</span>)</span><br><span class="line">            c = queue[child = right];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (comparator.compare(x, (E) c) &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        queue[k] = c;</span><br><span class="line">        k = child;</span><br><span class="line">    &#125;</span><br><span class="line">    queue[k] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、PriorityBlockingQueue"><a href="#四、PriorityBlockingQueue" class="headerlink" title="四、PriorityBlockingQueue"></a>四、PriorityBlockingQueue</h3><p>这个阻塞的优先级队列的实现跟PriorityQueue基本一模一样，只是PriorityBlockingQueue基于Lock锁实现的多线程操作安全并且线程可以挂起阻塞的操作</p>
<p>PriorityBlockingQueue底层基于数组，并且可以扩容，不会基于condition挂起线程，读会阻塞。</p>
<h4 id="4-1-写操作"><a href="#4-1-写操作" class="headerlink" title="4.1 写操作"></a>4.1 写操作</h4><p>因为底层基于数组，并且可以扩容，所以写操作的put和poll(time,unit)的方式不会基于condition挂起线程。</p>
<p>并且是多线程基于CAS的方式争抢扩容的标识</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有添加都走着，没有await挂起的方式，</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="type">int</span> n, cap;</span><br><span class="line">    Object[] array;</span><br><span class="line">    <span class="comment">// 扩容，允许多线程并发扩容。一会看~~~</span></span><br><span class="line">    <span class="keyword">while</span> ((n = size) &gt;= (cap = (array = queue).length))</span><br><span class="line">        tryGrow(array, cap);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//添加数据到二叉堆</span></span><br><span class="line">            siftUpComparable(n, e, array);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftUpUsingComparator(n, e, array, cmp);</span><br><span class="line">        size = n + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 唤醒读线程</span></span><br><span class="line">        notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跟PriorityQueue一样的上移操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">siftUpComparable</span><span class="params">(<span class="type">int</span> k, T x, Object[] array)</span> &#123;</span><br><span class="line">    Comparable&lt;? <span class="built_in">super</span> T&gt; key = (Comparable&lt;? <span class="built_in">super</span> T&gt;) x;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (k - <span class="number">1</span>) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">e</span> <span class="operator">=</span> array[parent];</span><br><span class="line">        <span class="keyword">if</span> (key.compareTo((T) e) &gt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        array[k] = e;</span><br><span class="line">        k = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    array[k] = key;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试扩容</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryGrow</span><span class="params">(Object[] array, <span class="type">int</span> oldCap)</span> &#123;</span><br><span class="line">    <span class="comment">// 允许多线程并发扩容的。（不是协助扩容），但是只有一个线程会成功，基于CAS的方式，避免并发问题</span></span><br><span class="line">    lock.unlock();</span><br><span class="line"></span><br><span class="line">    Object[] newArray = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 线程将allocationSpinLock从0改为1，得到了扩容的权利，可以创建新数组</span></span><br><span class="line">    <span class="keyword">if</span> (allocationSpinLock == <span class="number">0</span> &amp;&amp; UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, allocationSpinLockOffset,<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 计算新数组长度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">newCap</span> <span class="operator">=</span> oldCap + ((oldCap &lt; <span class="number">64</span>) ? (oldCap + <span class="number">2</span>) :  (oldCap &gt;&gt; <span class="number">1</span>));</span><br><span class="line">            <span class="comment">// 判断长度是否超过界限</span></span><br><span class="line">            <span class="keyword">if</span> (newCap - MAX_ARRAY_SIZE &gt; <span class="number">0</span>) &#123;  </span><br><span class="line">                <span class="type">int</span> <span class="variable">minCap</span> <span class="operator">=</span> oldCap + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (minCap &lt; <span class="number">0</span> || minCap &gt; MAX_ARRAY_SIZE)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OutOfMemoryError</span>();</span><br><span class="line">                newCap = MAX_ARRAY_SIZE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newCap &gt; oldCap &amp;&amp; queue == array)</span><br><span class="line">                <span class="comment">// 创建新数组</span></span><br><span class="line">                newArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newCap];</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            allocationSpinLock = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newArray == <span class="literal">null</span>) </span><br><span class="line">        <span class="comment">// 如果newArray是null，说明当前线程没有执行扩容操作</span></span><br><span class="line">        <span class="comment">// 让出CPU时间片，尽量让扩容的线程先走完扩容操作</span></span><br><span class="line">        Thread.<span class="keyword">yield</span>();</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">if</span> (newArray != <span class="literal">null</span> &amp;&amp; queue == array) &#123;</span><br><span class="line">        queue = newArray;</span><br><span class="line">        <span class="comment">// 扩容结束</span></span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, oldCap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-2-读操作"><a href="#4-2-读操作" class="headerlink" title="4.2 读操作"></a>4.2 读操作</h4><p>PriorityBlockingQueue的读操作，是允许使用condition挂起的，因为二叉堆可能没有数据。没有数据，就挂起呗~~</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 基于lock锁保证安全，</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> E <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Object[] array = queue;</span><br><span class="line">        <span class="comment">// 拿到堆顶数据</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> (E) array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">E</span> <span class="variable">x</span> <span class="operator">=</span> (E) array[n];</span><br><span class="line">        array[n] = <span class="literal">null</span>;</span><br><span class="line">        Comparator&lt;? <span class="built_in">super</span> E&gt; cmp = comparator;</span><br><span class="line">        <span class="keyword">if</span> (cmp == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 保证结构，下移~~</span></span><br><span class="line">            siftDownComparable(<span class="number">0</span>, x, array, n);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            siftDownUsingComparator(<span class="number">0</span>, x, array, n, cmp);</span><br><span class="line">        size = n;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="literal">null</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    E result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ( (result = dequeue()) == <span class="literal">null</span> &amp;&amp; nanos &gt; <span class="number">0</span>)</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="九、JUC阻塞队列第二弹"><a href="#九、JUC阻塞队列第二弹" class="headerlink" title="九、JUC阻塞队列第二弹"></a>九、<strong>JUC阻塞队列第二弹</strong></h1><h3 id="一、DelayQueue"><a href="#一、DelayQueue" class="headerlink" title="一、DelayQueue"></a>一、DelayQueue</h3><p>在学习Delay的原理之前，先掌握应用。</p>
<p>如果需要掌握源码的话，需要对PriorityQueue有一定掌握，也就是二叉堆。</p>
<h4 id="1-1-掌握DelayQueue应用"><a href="#1-1-掌握DelayQueue应用" class="headerlink" title="1.1 掌握DelayQueue应用"></a>1.1 掌握DelayQueue应用</h4><p>DelayQueue是无界队列</p>
<p>延迟的操作，可以向延迟队列中追加任务，这个任务需要指定延迟时间。</p>
<p>只有延迟时间到了，才可以将任务从队列中获取出来。</p>
<p>任务可以指定延迟时间，所以需要任务满足一定的需求</p>
<p>发现DelayQueue中的任务需要实现Delayed接口，重写getDelay和compareTo方法</p>
<p>getDelay：任务什么时候可以出队列</p>
<p>compareTo：存放任务到队列时，放在二叉堆的哪个位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Delayed</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  执行时间 （单位毫秒） */</span></span><br><span class="line">    <span class="keyword">private</span> Long time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name  任务名称</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayTime  传入延迟时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">(String name, Long delayTime)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.time = System.currentTimeMillis() + delayTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 任务可以出队列的核心方法 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(time - System.currentTimeMillis(),TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过这个方法，来比较，将任务存放到二叉堆的指定位置 */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed o)</span> &#123;</span><br><span class="line">        <span class="comment">// 基于执行时间比较</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (<span class="built_in">this</span>.time - ((Task)o).getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试效果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">DelayQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelayQueue</span>();</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;A&quot;</span>,<span class="number">4000L</span>));</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;B&quot;</span>,<span class="number">2000L</span>));</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;C&quot;</span>,<span class="number">3000L</span>));</span><br><span class="line">    queue.offer(<span class="keyword">new</span> <span class="title class_">Task</span>(<span class="string">&quot;D&quot;</span>,<span class="number">1000L</span>));</span><br><span class="line"></span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">    System.out.println(queue.take());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-分析源码"><a href="#1-2-分析源码" class="headerlink" title="1.2 分析源码"></a>1.2 分析源码</h4><p>首先，想掌握延迟队列的源码信息，你需要先掌握优先级队列。</p>
<p>PriorityQueue，这个优先级队列是基于二叉堆。</p>
<p>二叉堆跟二叉树结构很像，二叉堆就是满二叉树。</p>
<p>优先级队列是基于<a href="">数组</a>实现的， 在队列内部会对每个节点做排序</p>
<p>二叉堆存放数据的顺序是固定的，并且没插入一个数据，会基于<a href="">上移</a>操作保证小顶堆的结构</p>
<p>如果取出数据，要涉及到<a href="">下移</a>来保证小顶堆结构</p>
<p>延迟队列就是基于优先级队列实现的</p>
<p>看延迟队列的添加任务方法</p>
<p>因为DelayQueue是无界队列，空间不够会扩容，生产者不需要挂起线程，空间肯定可以存放下当前的任务节点</p>
<p>只需要查看offer即可，其他的方法也都是调用的offer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延迟队列，就这么一个添加任务的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用优先级队列，添加任务</span></span><br><span class="line">        q.offer(e);</span><br><span class="line">        <span class="comment">// 拿到第一个数据，看看我是不是第一个，如果是第一个，可能有消费者挂起了，唤醒一波</span></span><br><span class="line">        <span class="keyword">if</span> (q.peek() == e) &#123;</span><br><span class="line">            <span class="comment">// 一会说！！！！</span></span><br><span class="line">            leader = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// condition啊，await挂起线程，signal唤醒线程</span></span><br><span class="line">            available.signal();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ok~返回true</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个是优先级队列的添加，延迟队列是基于优先级队列实现的功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size;</span><br><span class="line">    <span class="comment">// 空间不够，扩容数组</span></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= queue.length)</span><br><span class="line">        grow(i + <span class="number">1</span>);</span><br><span class="line">    size = i + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 放第一个数据，不需要上移</span></span><br><span class="line">        queue[<span class="number">0</span>] = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 不是一个数据，判断是否需要上移</span></span><br><span class="line">        siftUp(i, e);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据怎么从延迟队列拿出来的</p>
<p>浅尝的poll()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者浅尝一下拿数据，如果有数据，并且延迟时间已经到了，返回，否则啥也不干</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 拿到堆顶数据</span></span><br><span class="line">        <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek();</span><br><span class="line">        <span class="comment">// 如果没数据，或者数据的延迟时间没到，返回null</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="literal">null</span> || first.getDelay(NANOSECONDS) &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 如果有数据，并且时间到了，基于优先级队列，把任务取出来。  </span></span><br><span class="line">            <span class="keyword">return</span> q.poll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>浅尝一会的poll(time,unit)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尝一小会~~~尝  timeout时间</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 纳秒判断</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="built_in">this</span>.lock;</span><br><span class="line">    <span class="comment">// 这里加锁，允许中断。</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 拿堆顶</span></span><br><span class="line">            <span class="type">E</span> <span class="variable">first</span> <span class="operator">=</span> q.peek();</span><br><span class="line">            <span class="comment">// 没数据，判断等多久</span></span><br><span class="line">            <span class="keyword">if</span> (first == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 时间没了，告辞！！！！</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 时间还有，等一小会~~</span></span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 必然有数据！！！！</span></span><br><span class="line">                <span class="comment">// 取出堆顶数据的剩余时间</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> first.getDelay(NANOSECONDS);</span><br><span class="line">                <span class="comment">// 如果时间已经到位了，直接调用优先级队列，把数据取出来</span></span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> q.poll();</span><br><span class="line">                <span class="comment">// 再次判断等待时间</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="comment">// 不等，告辞！！！！！！！！！！！</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 将临时变量置位null</span></span><br><span class="line">                first = <span class="literal">null</span>; </span><br><span class="line">                <span class="comment">// 如果剩余的等待时间，小于任务的延迟时间，肯定拿不到数据的，等着玩，反正拿不到</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt; delay || leader != <span class="literal">null</span>)</span><br><span class="line">                    nanos = available.awaitNanos(nanos);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 我等待的时间内，必然可以拿到数据，并且没有leader</span></span><br><span class="line">                    <span class="type">Thread</span> <span class="variable">thisThread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                    <span class="comment">// 将当前线程置位leader，说明我是第一个在这等待数据的线程！！！！</span></span><br><span class="line">                    leader = thisThread;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 当前线程先挂起，挂起任务剩余的延迟时间，会释放锁！</span></span><br><span class="line">                        <span class="type">long</span> <span class="variable">timeLeft</span> <span class="operator">=</span> available.awaitNanos(delay);</span><br><span class="line">                        <span class="comment">// 重新计算剩余的等待时间</span></span><br><span class="line">                        nanos -= delay - timeLeft;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// 将leader置位null</span></span><br><span class="line">                        <span class="keyword">if</span> (leader == thisThread)</span><br><span class="line">                            leader = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果leader为null，并且堆顶有数据，执行唤醒操作</span></span><br><span class="line">        <span class="keyword">if</span> (leader == <span class="literal">null</span> &amp;&amp; q.peek() != <span class="literal">null</span>)</span><br><span class="line">            available.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而take方法，会调用await()，一致阻塞，直到拿到数据。</p>
<p>与poll(time,unit)的区别是，poll(time,unit)会计算剩余额的阻塞时间，take不会。</p>
<hr>
<p>首先知道了DelayQueue如何用代码实现，首先节点就是任务必须实现Delayed接口，重写任务<a href="getDelay">出队的时间</a>以及任务的<a href="compareTo">排序方式</a></p>
<p>入队：入队只有一个方法，就是offer，因为DelayQueue是无界队列，所以生产者是不需要阻塞的</p>
<p>出队：</p>
<ul>
<li>poll：直接拿堆顶数据，堆顶的延迟时间到了，直接返回任务，如果没到时间，返回null。</li>
<li>poll(time,unit)：<ul>
<li>直接拿堆顶数据，<ul>
<li>如果为null，或者阻塞时间已经到了，直接告辞！</li>
<li>如果不为null<ul>
<li>并且延迟时间到了，返回数据</li>
<li>如果数据时间没到，查看阻塞剩余的时间到了么，到了直接返回null</li>
<li>如果数据的延迟时间没到<ul>
<li>如果阻塞时间小于延迟时间，或者已经有leader了，直接等待阻塞时间，等待被唤醒即可</li>
<li>当前阻塞时间大于等于延迟时间，并且leader为null，这是就阻塞延迟时间即可</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="二、SynchronousQueue"><a href="#二、SynchronousQueue" class="headerlink" title="二、SynchronousQueue"></a>二、SynchronousQueue</h3><h4 id="2-1-介绍-amp-应用"><a href="#2-1-介绍-amp-应用" class="headerlink" title="2.1 介绍&amp;应用"></a>2.1 介绍&amp;应用</h4><p>SynchronousQueue和其他阻塞队列有点区别，但是也是阻塞的！</p>
<p>SynchronousQueue并不存储数据，队列的长度是0，一个生产者扔数据到SynchronousQueue后，必须等待消费者拿走这个数据才可以。</p>
<p>跟Exchanger很像，Exchanger是两个线程交换数据，SynchronousQueue是传递数据，不是交换</p>
<p>应用的方向是线程间的通讯，可以使用。</p>
<p>使用的方法：</p>
<p>offer()：拿着数据到了SynchronousQueue，如果恰巧有消费者在等待拿数据，配对成功！</p>
<p>offer(time,unit)：着数据到了SynchronousQueue，可以等一会，如果期间有消费者来了，配对成功！</p>
<p>put()：着数据到了SynchronousQueue，死等，直到消费者来了，或者被中断了。</p>
<p>poll，poll(time,unit)，take，你懂得！</p>
<p>浅尝一下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">SynchronousQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span>  <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;jack&amp;rose&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;publisher：&quot;</span> + user);</span><br><span class="line">        queue.offer(user);</span><br><span class="line">    &#125;).start();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">user</span> <span class="operator">=</span> queue.take();</span><br><span class="line">            System.out.println(<span class="string">&quot;consumer：&quot;</span> + user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-核心内容"><a href="#2-1-核心内容" class="headerlink" title="2.1 核心内容"></a>2.1 核心内容</h4><p>首先想要掌握SynchronousQueue，必须了解Transferer。</p>
<p>因为SynchronousQueue无论是消费者还是生产者，都用到了Transferer中的transfer方法</p>
<p>生产者调用transfer方法，需要传递一个参数，也就是数据</p>
<p>消费者调用transfer方法，第一个参数传递为null，代表获取数据</p>
<p>Transferer有两个实现，分别对应了SynchronousQueue的公平操作和不公平操作</p>
<ul>
<li>TransferQueue代表公平处理方式</li>
<li>TransferStack代表不公平处理方式</li>
</ul>
<p>查看TransferQueue内部的实现，查看核心属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是 TransferQueue 中的每一个节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">QNode</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> QNode next;   </span><br><span class="line">    <span class="keyword">volatile</span> Object item;   </span><br><span class="line">    <span class="comment">// 如果执行了put、take方法时，需要挂起线程，而挂起的就是这个线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;   </span><br><span class="line">    <span class="comment">// true：生产者</span></span><br><span class="line">    <span class="comment">// false：消费者</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> isData;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="comment">/** Head of queue */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode head;</span><br><span class="line"><span class="comment">/** Tail of queue */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> QNode tail;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无参构造</span></span><br><span class="line">TransferQueue() &#123;</span><br><span class="line">    <span class="comment">// 会先初始化一个QNode，作为head和tail的指向，并且这个QNode不包含线程信息，就一个伪的头结点</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QNode</span>(<span class="literal">null</span>, <span class="literal">false</span>); <span class="comment">// initialize to dummy node.</span></span><br><span class="line">    head = h;</span><br><span class="line">    tail = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-生产者和消费者执行套路"><a href="#2-3-生产者和消费者执行套路" class="headerlink" title="2.3 生产者和消费者执行套路"></a>2.3 生产者和消费者执行套路</h4><p>生产者：执行transfer方法时，会传递值</p>
<ul>
<li>offer：传递的nacos为0</li>
<li>offer浅等：传递的nacos是指定数值</li>
<li>put：timed设置为false</li>
</ul>
<p>消费者：执行transfer方法时，第一个参数会设置为null</p>
<ul>
<li>poll，poll浅等，take方法与生产者一致。</li>
</ul>
<p>分析TransferQueue的transfer方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费者和生产者都会调用这个房</span></span><br><span class="line">E <span class="title function_">transfer</span><span class="params">(E e, <span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> &#123;</span><br><span class="line">    <span class="comment">// 声明QNode</span></span><br><span class="line">    <span class="type">QNode</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">// 判断当前操作的是消费者还是生产者</span></span><br><span class="line">    <span class="comment">// true：生</span></span><br><span class="line">    <span class="comment">// false：消</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isData</span> <span class="operator">=</span> (e != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 拿到头尾节点</span></span><br><span class="line">        <span class="type">QNode</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="type">QNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">// 健壮性判断</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span> || h == <span class="literal">null</span>)   </span><br><span class="line">            <span class="keyword">continue</span>;   </span><br><span class="line">        <span class="comment">// 如果头和尾相等。</span></span><br><span class="line">        <span class="comment">// 在当前的QNode单向链表中，要么都存放生产者，要么都存放消费者。</span></span><br><span class="line">        <span class="comment">// 所以第二个判断是，如果队列中有Qnode，查看我当前的isData是否和队列中Qnode的isData一致，一致挂上去</span></span><br><span class="line">        <span class="keyword">if</span> (h == t || t.isData == isData) &#123; </span><br><span class="line">            <span class="comment">// 拿到t.next</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">tn</span> <span class="operator">=</span> t.next;</span><br><span class="line">            <span class="comment">// --------------------避免并发-----------------------------</span></span><br><span class="line">            <span class="comment">// 出现了并发操作，重新执行for循环</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail)  </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果尾节点的next不为null，有并发情况</span></span><br><span class="line">            <span class="keyword">if</span> (tn != <span class="literal">null</span>) &#123;   </span><br><span class="line">                <span class="comment">// 直接CAS操作，将tail的next节点设置为tail节点  </span></span><br><span class="line">                advanceTail(t, tn);</span><br><span class="line">                <span class="comment">// 重新执行for循环</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// timed == true： offer，poll</span></span><br><span class="line">            <span class="comment">// 进来之后没有立即配对，那就直接告辞！</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0</span>)  </span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 把当前的QNode初始化。</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="literal">null</span>)</span><br><span class="line">                s = <span class="keyword">new</span> <span class="title class_">QNode</span>(e, isData);</span><br><span class="line">            <span class="comment">// 将tail的next指向的当前QNode</span></span><br><span class="line">            <span class="keyword">if</span> (!t.casNext(<span class="literal">null</span>, s))  </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 将tail指向当前Qnode</span></span><br><span class="line">            advanceTail(t, s);  </span><br><span class="line">            <span class="comment">// 等！！！（挂起线程），直到被唤醒，拿到指定的item数据</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> awaitFulfill(s, e, timed, nanos);</span><br><span class="line">            <span class="comment">// 拿到的数据和当前QNode一致，当前节点取消了</span></span><br><span class="line">            <span class="keyword">if</span> (x == s) &#123;  </span><br><span class="line">                <span class="comment">// 清除当前节点，告辞！！！   </span></span><br><span class="line">                clean(t, s);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否还在队列中</span></span><br><span class="line">            <span class="keyword">if</span> (!s.isOffList()) &#123;  </span><br><span class="line">                <span class="comment">// 将当前节点设置为新的head</span></span><br><span class="line">                advanceHead(t, s);  </span><br><span class="line">                <span class="keyword">if</span> (x != <span class="literal">null</span>)  </span><br><span class="line">                    <span class="comment">// 我拿到数据了，设置item为当前节点对象</span></span><br><span class="line">                    s.item = s;</span><br><span class="line">                <span class="comment">// 线程置位null</span></span><br><span class="line">                s.waiter = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回数据</span></span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   </span><br><span class="line">            <span class="comment">// 如果逻辑到这，需要跟队列中的Qnode做配对。</span></span><br><span class="line">            <span class="comment">// 拿到head的next，m</span></span><br><span class="line">            <span class="type">QNode</span> <span class="variable">m</span> <span class="operator">=</span> h.next;   </span><br><span class="line">            <span class="comment">// 并发问题，重新循环</span></span><br><span class="line">            <span class="keyword">if</span> (t != tail || m == <span class="literal">null</span> || h != head)</span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="comment">// 拿到m中的数据。</span></span><br><span class="line">            <span class="comment">// x == null：队列是消费者</span></span><br><span class="line">            <span class="comment">// x != null：队列是生产者</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> m.item;</span><br><span class="line">            <span class="comment">// 1、出现并发问题，装车了</span></span><br><span class="line">            <span class="comment">// 2、取出的数据，竟然是节点本身，代表节点被取消！</span></span><br><span class="line">            <span class="comment">// 3、开始交换数据，将当前方法传入数据，替换到head的next，如果操作失败，并发问题</span></span><br><span class="line">            <span class="keyword">if</span> (isData == (x != <span class="literal">null</span>) ||  x == m || !m.casItem(x, e)) &#123;  </span><br><span class="line">                <span class="comment">// 配对失败，重新替换head节点   </span></span><br><span class="line">                advanceHead(h, m);  </span><br><span class="line">                <span class="comment">// 重新for循环  </span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 操作成功，也要替换head</span></span><br><span class="line">            advanceHead(h, m);  </span><br><span class="line">            <span class="comment">// 唤醒队列中的head的next节点的线程。   </span></span><br><span class="line">            LockSupport.unpark(m.waiter);</span><br><span class="line">            <span class="comment">// 操作成功，返回数据！</span></span><br><span class="line">            <span class="keyword">return</span> (x != <span class="literal">null</span>) ? (E)x : e;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十、ScheduledThreadPoolExecutor"><a href="#十、ScheduledThreadPoolExecutor" class="headerlink" title="十、ScheduledThreadPoolExecutor"></a>十、<strong>ScheduledThreadPoolExecutor</strong></h1><h3 id="一、ScheduledThreadPoolExecutor介绍-amp-应用"><a href="#一、ScheduledThreadPoolExecutor介绍-amp-应用" class="headerlink" title="一、ScheduledThreadPoolExecutor介绍&amp;应用"></a>一、ScheduledThreadPoolExecutor介绍&amp;应用</h3><p>ScheduledThreadPoolExecutor是ThreadPoolExecutor的一个子类，在线程池的基础上实现了延迟执行任务以及周期性执行任务的功能。</p>
<p>Java最早提供的是Timer类执行定时任务，串行的，不靠谱，会影响到其他的任务执行，在不采用第三方框架时，需要执行定时任务，ScheduledThreadPoolExecutor是比较好的选择。</p>
<p>ScheduledThreadPoolExecutor就是在线程池的基础上实现的定时执行任务的功能。</p>
<p>ScheduledThreadPoolExecutor提供了比较常用的四种方法执行任务：（不说Callable）</p>
<ul>
<li>execute：跟普通线程池执行没区别。</li>
<li>schedule：可以指定延迟时间，一次性执行任务。</li>
<li>scheduleAtFixedRate：可以让任务在固定的周期下执行。（任务的处理时间，不影响下次执行时间，如果任务的执行时间超过了设置的延迟时间，按照时间最长的计算）</li>
<li>scheduleWithFixedDelay：可以让任务在固定的周期下执行。（任务的处理时间，影响下次执行时间）</li>
</ul>
<p>应用效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ScheduledThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ScheduledThreadPoolExecutor</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. execute</span></span><br><span class="line">    executor.execute(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;execute&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. schedule</span></span><br><span class="line">    executor.schedule(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;schedule&quot;</span>);</span><br><span class="line">    &#125;,<span class="number">2000</span>,TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. AtFixedRate</span></span><br><span class="line">    executor.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">4000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;at:&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;,<span class="number">3000</span>,<span class="number">2000</span>,TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4. WithFixedDelay</span></span><br><span class="line">    executor.scheduleWithFixedDelay(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;with:&quot;</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;,<span class="number">3000</span>,<span class="number">2000</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果实际开发应用需要使用到定人任务，更推荐一些开源你的框架，比如Quartz，XXL-job，Elastic-Job</p>
<p>因为corn表达式，对时间的控制更加方便！</p>
<h3 id="二、ScheduleThreadPoolExecutor底层结构"><a href="#二、ScheduleThreadPoolExecutor底层结构" class="headerlink" title="二、ScheduleThreadPoolExecutor底层结构"></a>二、ScheduleThreadPoolExecutor底层结构</h3><p>两个核心内容</p>
<h4 id="2-1-ScheduledFutureTask"><a href="#2-1-ScheduledFutureTask" class="headerlink" title="2.1 ScheduledFutureTask"></a>2.1 ScheduledFutureTask</h4><p>首先看到了核心内容，ScheduledFutureTask间接的实现了Delayed接口，让任务可以放到延迟队列中，并且基于二叉堆做排序，即将执行的时间越短，就往堆顶扔，查看核心内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">ScheduledFutureTask</span>&lt;V&gt;</span><br><span class="line">        <span class="keyword">extends</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableScheduledFuture</span>&lt;V&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就是计数器，每个任务进来时，都会有一个全局唯一的序号。</span></span><br><span class="line">    <span class="comment">// 如果任务的执行时间一模一样，比对sequenceNumber</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务执行的时间，单位是纳秒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * period == 0：表示一次性执行的任务</span></span><br><span class="line"><span class="comment">     * period &gt; 0：表示使用的是At！</span></span><br><span class="line"><span class="comment">     * period &lt; 0：表示使用的是With！</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> period;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 周期性实行任务时，引用具体任务，方便后面重新扔到阻塞队列</span></span><br><span class="line">    RunnableScheduledFuture&lt;V&gt; outerTask = <span class="built_in">this</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有参构造。schedule时使用当前有参重载封装任务！</span></span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="type">long</span> ns) &#123;</span><br><span class="line">        <span class="built_in">super</span>(r, result);</span><br><span class="line">        <span class="built_in">this</span>.time = ns;</span><br><span class="line">        <span class="built_in">this</span>.period = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At,With时，使用当前有参重载封装任务！</span></span><br><span class="line">    ScheduledFutureTask(Runnable r, V result, <span class="type">long</span> ns, <span class="type">long</span> period) &#123;</span><br><span class="line">        <span class="built_in">super</span>(r, result);</span><br><span class="line">        <span class="built_in">this</span>.time = ns;</span><br><span class="line">        <span class="built_in">this</span>.period = period;</span><br><span class="line">        <span class="built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不考虑这个，有返回结果</span></span><br><span class="line">    ScheduledFutureTask(Callable&lt;V&gt; callable, <span class="type">long</span> ns) &#123;</span><br><span class="line">        <span class="built_in">super</span>(callable);</span><br><span class="line">        <span class="built_in">this</span>.time = ns;</span><br><span class="line">        <span class="built_in">this</span>.period = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现Delayed接口重写的方法，执行的时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getDelay</span><span class="params">(TimeUnit unit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert(time - now(), NANOSECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现Delayed接口重写的方法，比较的方式，放在二叉堆内部</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Delayed other)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (other == <span class="built_in">this</span>) <span class="comment">// compare zero if same object</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (other <span class="keyword">instanceof</span> ScheduledFutureTask) &#123;</span><br><span class="line">            ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;</span><br><span class="line">            <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> time - x.time;</span><br><span class="line">            <span class="keyword">if</span> (diff &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sequenceNumber &lt; x.sequenceNumber)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">diff</span> <span class="operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);</span><br><span class="line">        <span class="keyword">return</span> (diff &lt; <span class="number">0</span>) ? -<span class="number">1</span> : (diff &gt; <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是周期执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPeriodic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> period != <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-DelayedWorkQueue"><a href="#2-2-DelayedWorkQueue" class="headerlink" title="2.2 DelayedWorkQueue"></a>2.2 DelayedWorkQueue</h4><p>阿巴阿巴！！！！</p>
<h3 id="三、execute方法分析"><a href="#三、execute方法分析" class="headerlink" title="三、execute方法分析"></a>三、execute方法分析</h3><p>这个方法是白给的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">    schedule(command, <span class="number">0</span>, NANOSECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看schedule即可</p>
<h3 id="四、schedule方法分析"><a href="#四、schedule方法分析" class="headerlink" title="四、schedule方法分析"></a>四、schedule方法分析</h3><p><strong>封装任务-放延迟队列-创建线程准备执行</strong></p>
<p>将传入的command任务和延迟执行的时间封装</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析定时任务线程的schedule，延迟一段时间，执行一次command任务</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay,TimeUnit unit) &#123;</span><br><span class="line">    <span class="comment">// 非空判断！</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 封装任务，将普通的command封住为ScheduledFutureTask、</span></span><br><span class="line">    <span class="comment">// decorateTask方法默认情况下，什么都没做，就是返回了ScheduledFutureTask</span></span><br><span class="line">    <span class="comment">// decorateTask方法是线程池给你提供的扩展方法，可以在这个位置修改任务需要执行的具体细节</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,<span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>,triggerTime(delay, unit)));</span><br><span class="line">    <span class="comment">// 延迟执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看triggerTime</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">triggerTime</span><span class="params">(<span class="type">long</span> delay, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> triggerTime(unit.toNanos((delay &lt; <span class="number">0</span>) ? <span class="number">0</span> : delay));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查看triggerTime方法重载，返回当前任务要执行的系统时间。</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">triggerTime</span><span class="params">(<span class="type">long</span> delay)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断delay时间是否小于Long.MAX_VALUE &gt;&gt; 1，</span></span><br><span class="line">    <span class="comment">// 如果小于,正常计算执行的时间</span></span><br><span class="line">    <span class="comment">// 如果大于，可能出现超过long的取值范围问题，做额外处理</span></span><br><span class="line">    <span class="keyword">return</span> now() + ((delay &lt; (Long.MAX_VALUE &gt;&gt; <span class="number">1</span>)) ? delay : overflowFree(delay));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将command任务封装为ScheduledFutureTask</span></span><br><span class="line">ScheduledFutureTask(Runnable r, V result, <span class="type">long</span> ns) &#123;</span><br><span class="line">    <span class="built_in">super</span>(r, result);</span><br><span class="line">    <span class="comment">// 任务要执行的系统时间</span></span><br><span class="line">    <span class="built_in">this</span>.time = ns;</span><br><span class="line">    <span class="comment">// 任务是否是周期性执行</span></span><br><span class="line">    <span class="built_in">this</span>.period = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 基于AtomicLong计算序列化。</span></span><br><span class="line">    <span class="built_in">this</span>.sequenceNumber = sequencer.getAndIncrement();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ScheduleThreadPoolExecutor提供的一个扩展方法，可以在这个位置细粒度的修改任务执行的细节。</span></span><br><span class="line"><span class="keyword">protected</span> &lt;V&gt; RunnableScheduledFuture&lt;V&gt; <span class="title function_">decorateTask</span><span class="params">(Runnable runnable, RunnableScheduledFuture&lt;V&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> task;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行延迟任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分析定时任务线程的schedule，延迟一段时间，执行一次command任务</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="type">long</span> delay,TimeUnit unit) &#123;</span><br><span class="line">    <span class="comment">// 非空判断！</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 封装任务，将普通的command封住为ScheduledFutureTask、</span></span><br><span class="line">    <span class="comment">// decorateTask方法默认情况下，什么都没做，就是返回了ScheduledFutureTask</span></span><br><span class="line">    <span class="comment">// decorateTask方法是线程池给你提供的扩展方法，可以在这个位置修改任务需要执行的具体细节</span></span><br><span class="line">    RunnableScheduledFuture&lt;?&gt; t = decorateTask(command,<span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>,triggerTime(delay, unit)));</span><br><span class="line">    <span class="comment">// 延迟执行</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 延迟执行！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">delayedExecute</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="comment">// 查看线程池是不是已经不是RUNNING状态</span></span><br><span class="line">    <span class="keyword">if</span> (isShutdown())</span><br><span class="line">        <span class="comment">// 如果是，拒绝策略。</span></span><br><span class="line">        reject(task);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 到这说明线程池状态是RUNNING</span></span><br><span class="line">        <span class="comment">// 调用阻塞队列，将任务添加进去，将任务扔到了延迟队列中（二叉堆）</span></span><br><span class="line">        <span class="comment">// 在添加任务到延迟队列的数组时，会记录当前任务所在的索引位置，方便取消任务时，从数组中移除</span></span><br><span class="line">        <span class="comment">// heapIndex方便取消任务</span></span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 判断线程池是否不是RUNNING状态，如果不是RUNNING，就根据策略决定任务是否执行</span></span><br><span class="line">        <span class="comment">// 如果任务不需要执行了，调用remove方法，将任务从延迟队列移除，并且在if内部还会取消任务</span></span><br><span class="line">        <span class="keyword">if</span> (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 线程池状态没毛病，任务是需要执行的！</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果任务添加到了阻塞队列中，忽然线程池不是RUNNING状态，那么此时这个任务是否执行？</span></span><br><span class="line"><span class="comment">// periodic - true：代表是周期性执行的任务</span></span><br><span class="line"><span class="comment">// periodic - false：代表是一次性的延迟任务</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">canRunInCurrentRunState</span><span class="params">(<span class="type">boolean</span> periodic)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> isRunningOrShutdown(periodic ?</span><br><span class="line">                               continueExistingPeriodicTasksAfterShutdown :</span><br><span class="line">                               executeExistingDelayedTasksAfterShutdown);</span><br><span class="line">    <span class="comment">// 默认情况下，如果任务扔到了延迟队列中，有两个策略</span></span><br><span class="line">    <span class="comment">// 如果任务是周期性执行的，默认为false，</span></span><br><span class="line">    <span class="comment">// 如果任务是一次性的延迟任务，默认为true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前任务到底执行不执行</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isRunningOrShutdown</span><span class="params">(<span class="type">boolean</span> shutdownOK)</span> &#123;</span><br><span class="line">    <span class="comment">// 重新拿到线程池的ctl</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runStateOf(ctl.get());</span><br><span class="line">    <span class="comment">// 如果线程池是RUNNING，返回true</span></span><br><span class="line">    <span class="comment">// 如果线程池状态是SHUTDOWN，那么就配合策略返回true、false</span></span><br><span class="line">    <span class="keyword">return</span> rs == RUNNING || (rs == SHUTDOWN &amp;&amp; shutdownOK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ensurePrestart</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取线程池中的工作线程个数。</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">wc</span> <span class="operator">=</span> workerCountOf(ctl.get());</span><br><span class="line">    <span class="comment">// 如果工作线程个数，小于核心线程数，</span></span><br><span class="line">    <span class="keyword">if</span> (wc &lt; corePoolSize)</span><br><span class="line">        <span class="comment">// 创建核心线程，一致在阻塞队列的位置take，等待拿任务执行</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 如果工作线程数不小于核心线程，但是值为0，创建非核心线程执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (wc == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 创建非核心线程处理阻塞队列任务，而且只要阻塞队列没有任务了，当前线程立即销毁</span></span><br><span class="line">        addWorker(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看任务放到延迟队列后，是如何被工作线程取出来执行的</p>
<p>执行addWorker方法，会创建一个工作线程，工作线程在创建成功后，会执行start方法。在start方法执行后，会调用Worker的run方法，最终执行了runWorker方法，在runWorker方法中会在阻塞队列的位置执行take方法一直阻塞拿Runnable任务，拿到任务后就返回，然后执行。</p>
<p>所以需要查看的就是延迟队列的take方法，套路和之前讲的DelayQueue没有区别</p>
<p>在拿到任务后，会执行任务，也就是执行任务的run方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取任务是否是周期执行</span></span><br><span class="line">    <span class="comment">// true：周期执行</span></span><br><span class="line">    <span class="comment">// false：一次的延迟执行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">periodic</span> <span class="operator">=</span> isPeriodic();</span><br><span class="line">    <span class="comment">// 再次判断线程池状态是否不是RUNNING，如果不是RUNNING，并且SHUTDOWN情况也不允许执行，或者是STOP状态</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        <span class="comment">// 取消任务</span></span><br><span class="line">        cancel(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        <span class="comment">// 当前任务是一次性的延迟执行。执行任务具体的run方法，执行完，没了………………</span></span><br><span class="line">        ScheduledFutureTask.<span class="built_in">super</span>.run();</span><br><span class="line">    <span class="comment">// 后面是周期执行、省略部分代码…………</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、scheduleAtFixedRate和scheduleWithFixedDelay分析"><a href="#五、scheduleAtFixedRate和scheduleWithFixedDelay分析" class="headerlink" title="五、scheduleAtFixedRate和scheduleWithFixedDelay分析"></a>五、scheduleAtFixedRate和scheduleWithFixedDelay分析</h3><p>在执行方法的初期，封装任务时：</p>
<ul>
<li>At会将period设置为正数，代表固定周期执行表</li>
<li>With会将period设置为负数，代表在执行任务完毕后，再计算下次执行的时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 固定周期执行任务，如果任务的执行时间，超过周期，任务执行完，立即执行下一次任务。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(</span><br><span class="line">                        Runnable command,    <span class="comment">// 具体任务</span></span><br><span class="line">                        <span class="type">long</span> initialDelay,   <span class="comment">// 第一次执行的时间</span></span><br><span class="line">                        <span class="type">long</span> period,         <span class="comment">// 周期执行时间</span></span><br><span class="line">                        TimeUnit unit) &#123;     <span class="comment">// 时间单位</span></span><br><span class="line">    <span class="comment">// 阿巴阿巴~~~</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 如果传递的周期小于等于0，直接抛异常</span></span><br><span class="line">    <span class="keyword">if</span> (period &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>, triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(period));</span><br><span class="line">    <span class="comment">// 扩展</span></span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    <span class="comment">// 将任务设置给outerTask属性，方便后期重新扔到延迟队列</span></span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    <span class="comment">// 嗯哼~</span></span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 固定周期执行任务，会在任务执行完毕后，再计算下次执行的时间。</span></span><br><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                 <span class="type">long</span> initialDelay,</span><br><span class="line">                                                 <span class="type">long</span> delay,</span><br><span class="line">                                                 TimeUnit unit) &#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="literal">null</span> || unit == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    ScheduledFutureTask&lt;Void&gt; sft =</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="literal">null</span>, triggerTime(initialDelay, unit),</span><br><span class="line">                                      unit.toNanos(-delay));</span><br><span class="line">    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command, sft);</span><br><span class="line">    sft.outerTask = t;</span><br><span class="line">    delayedExecute(t);</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终两个方法都会调用delayedExecute方法区将任务扔到阻塞队列，并尝试是否需要构建工作线程，从而执行任务</p>
<p>工作线程会监听延迟队列，拿到任务后会调用任务的run方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 查看At和With可确定任务是周期执行</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">periodic</span> <span class="operator">=</span> isPeriodic();</span><br><span class="line">    <span class="comment">// 线程池状态对不！！</span></span><br><span class="line">    <span class="keyword">if</span> (!canRunInCurrentRunState(periodic))</span><br><span class="line">        cancel(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!periodic)</span><br><span class="line">        <span class="comment">// 一次性的延迟执行</span></span><br><span class="line">        ScheduledFutureTask.<span class="built_in">super</span>.run();</span><br><span class="line">    <span class="comment">// 到这，先执行任务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ScheduledFutureTask.<span class="built_in">super</span>.runAndReset()) &#123;</span><br><span class="line">        <span class="comment">// 设置下一次任务的运行时间</span></span><br><span class="line">        setNextRunTime();</span><br><span class="line">        reExecutePeriodic(outerTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算任务下次执行时间，time是任务执行的时间，而这里是time的上次的执行时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setNextRunTime</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到当前任务的period</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">p</span> <span class="operator">=</span> period;</span><br><span class="line">    <span class="comment">// period &gt; 0：At</span></span><br><span class="line">    <span class="keyword">if</span> (p &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 直接拿上次执行的时间，添加上周期时间，来计算下次执行的时间。</span></span><br><span class="line">        time = time + p;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// period &lt; 0：With</span></span><br><span class="line">        <span class="comment">// 任务执行完，拿当前系统时间计算下次执行的时间点</span></span><br><span class="line">        time = now() + p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新将任务扔到延迟队列中</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">reExecutePeriodic</span><span class="params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="comment">// 线程池状态的判断</span></span><br><span class="line">    <span class="keyword">if</span> (canRunInCurrentRunState(<span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="comment">// 将任务扔到了延迟队列中</span></span><br><span class="line">        <span class="built_in">super</span>.getQueue().add(task);</span><br><span class="line">        <span class="comment">// 扔到延迟队列后，再次判断线程池状态，是否需要取消任务！</span></span><br><span class="line">        <span class="keyword">if</span> (!canRunInCurrentRunState(<span class="literal">true</span>) &amp;&amp; remove(task))</span><br><span class="line">            task.cancel(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 需要创建线程不~</span></span><br><span class="line">            ensurePrestart();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同步、异步、阻塞、非阻塞。</p>
<p>同步：做了同步操作后，被调用者不会主动通知我结果，我需要主动查看结果。</p>
<p>异步：做了异步操作后，被调用者会主动通知我结果是什么。</p>
<p>阻塞：调用功能后，不能做其他事情。</p>
<p>非阻塞：调用功能后，可以做其他事情。</p>
<p>同步阻塞：执行烧水功能时，我不能做其他事情，并且烧水功能执行完后，不会主动通知我。</p>
<p>同步非阻塞：执行烧水功能时，我可以做其他事情，但是烧水功能执行完后，不会主动通知我。</p>
<p>异步阻塞：执行烧水功能时，我不能做其他事情，并且烧水功能执行完后，会主动通知我。（这个操作没有）</p>
<p>异步非阻塞：执行烧水功能时，我可以做其他事情，并且烧水功能执行完后，会主动通知我。</p>
<h1 id="十一、FutureTask源码"><a href="#十一、FutureTask源码" class="headerlink" title="十一、FutureTask源码"></a>十一、<strong>FutureTask源码</strong></h1><h2 id="一、Future介绍"><a href="#一、Future介绍" class="headerlink" title="一、Future介绍"></a>一、<strong>Future介绍</strong></h2><p>Future是个什么鬼？<br>Java创建线程的方式，一般常用的是Thread，Runnable。如果需要当前处理的任务有返回结果的话，<br>需要使用Callable。Callable运行需要配合Future。<br>Future是一个接口，一般会使用FutureTask实现类去接收Callable任务的返回结果。<br>FutureTask存在一些问题的，同步非阻塞执行的任务，他不会主动通知你返回结果是什么。</p>
<h2 id="二、FutureTask使用"><a href="#二、FutureTask使用" class="headerlink" title="二、FutureTask使用"></a>二、<strong>FutureTask使用</strong></h2><p>Callable是你要执行的任务。</p>
<p>FutureTask是存放任务返回结果的位置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;任务执行&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>+<span class="number">764</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;main线程启动了t线程处理任务&quot;</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、FutureTask源码分析"><a href="#三、FutureTask源码分析" class="headerlink" title="三、FutureTask源码分析"></a>三、<strong>FutureTask源码分析</strong></h2><p>要分析FutureTask，首先需要查看一下他的核心属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; NORMAL          任务正常执行，返回结果是正常的结果</span></span><br><span class="line"><span class="comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL     任务正常执行，但是返回结果是异常</span></span><br><span class="line"><span class="comment"> * NEW -&gt; CANCELLED              任务直接被取消的流程</span></span><br><span class="line"><span class="comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 代表当前任务的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> state;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NEW</span>          <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">// 任务的初始化状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COMPLETING</span>   <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// Callable的结果（正常结果，异常结果）正在封装给当前的FutureTask</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>       <span class="operator">=</span> <span class="number">2</span>;  <span class="comment">// NORMAL任务正常结束</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span>  <span class="operator">=</span> <span class="number">3</span>;  <span class="comment">// 执行任务时，发生了异常</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>    <span class="operator">=</span> <span class="number">4</span>;  <span class="comment">// 任务被取消了。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTING</span> <span class="operator">=</span> <span class="number">5</span>;  <span class="comment">// 线程的中断状态，被设置为了true（现在还在运行）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INTERRUPTED</span>  <span class="operator">=</span> <span class="number">6</span>;  <span class="comment">// 线程被中断了。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前要执行的任务</span></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; callable;</span><br><span class="line"><span class="comment">// 存放任务返回结果的属性，也就是futureTask.get需要获取的结果</span></span><br><span class="line"><span class="keyword">private</span> Object outcome; </span><br><span class="line"><span class="comment">// 执行任务的线程。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> Thread runner;</span><br><span class="line"><span class="comment">// 单向链表，存放通过get方法挂起等待的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure>
<p>t.start后，如何执行Callable的call方法，其实是通过run方法执行的call方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run方法的执行流程，最终会执行Callable的call方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 保证任务的状态是NEW才可以运行</span></span><br><span class="line">    <span class="comment">// 基于CAS的方式，将当前线程设置为runner。</span></span><br><span class="line">    <span class="keyword">if</span> (state != NEW ||</span><br><span class="line">        !UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, runnerOffset,<span class="literal">null</span>, Thread.currentThread()))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 准备执行任务</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 要执行任务 c</span></span><br><span class="line">        Callable&lt;V&gt; c = callable;</span><br><span class="line">        <span class="comment">// 任务不为null，并且任务的状态还处于NEW</span></span><br><span class="line">        <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class="line">            <span class="comment">// 放返回结果</span></span><br><span class="line">            V result;</span><br><span class="line">            <span class="comment">// 任务执行是否为正常结束</span></span><br><span class="line">            <span class="type">boolean</span> ran;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 运行call方法，拿到返回结果封装到result中</span></span><br><span class="line">                result = c.call();</span><br><span class="line">                <span class="comment">// 正常返回，ran设置为true</span></span><br><span class="line">                ran = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 结果为null</span></span><br><span class="line">                result = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 异常返回，ran设置为false</span></span><br><span class="line">                ran = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 设置异常信息</span></span><br><span class="line">                setException(ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ran)</span><br><span class="line">                <span class="comment">// 正常执行结束，设置返回结果</span></span><br><span class="line">                set(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 将执行任务的runner设置空</span></span><br><span class="line">        runner = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 拿到状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="comment">// 中断要做一些后续处理</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</span><br><span class="line">            handlePossibleCancellationInterrupt(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置返回结果</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(V v)</span> &#123;</span><br><span class="line">    <span class="comment">// 首先要将任务状态从NEW设置为COMPLETING</span></span><br><span class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;</span><br><span class="line">        <span class="comment">// 将返回结果设置给outcome。</span></span><br><span class="line">        outcome = v;</span><br><span class="line">        <span class="comment">// 将状态修改为NORMAL，代表正常技术</span></span><br><span class="line">        UNSAFE.putOrderedInt(<span class="built_in">this</span>, stateOffset, NORMAL);</span><br><span class="line">        <span class="comment">// 一会再说，你猜猜~~~</span></span><br><span class="line">        finishCompletion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get方法获取返回结果，到挂起的位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">    <span class="comment">// 拿状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">    <span class="comment">// 满足找个状态就代表现在可能还没有返回结果</span></span><br><span class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</span><br><span class="line">        <span class="comment">// 尝试挂起线程，等待拿结果</span></span><br><span class="line">        s = awaitDone(<span class="literal">false</span>, <span class="number">0L</span>);</span><br><span class="line">    <span class="keyword">return</span> report(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程要等待任务执行结束，等待任务执行的状态变为大于COMPLETING状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">awaitDone</span><span class="params">(<span class="type">boolean</span> timed, <span class="type">long</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 计算deadline，如果是get()，就是0，  如果是get(time,unit)那就追加当前系统时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">deadline</span> <span class="operator">=</span> timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// 构建WaitNode</span></span><br><span class="line">    <span class="type">WaitNode</span> <span class="variable">q</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// queued = false</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">queued</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 死循环</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 找个get的线程是否中断了。</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            <span class="comment">// 将当前节点从waiters中移除。</span></span><br><span class="line">            removeWaiter(q);</span><br><span class="line">            <span class="comment">// 并且抛出中断异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拿到现在任务的状态</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> state;</span><br><span class="line">        <span class="comment">// 判断任务是否已经执行结束了</span></span><br><span class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</span><br><span class="line">            <span class="comment">// 如果设置过WaitNode，直接移除WaitNode的线程</span></span><br><span class="line">            <span class="keyword">if</span> (q != <span class="literal">null</span>)</span><br><span class="line">                q.thread = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 返回当前任务的状态</span></span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果任务的状态处于 COMPLETING ，</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING)</span><br><span class="line">            <span class="comment">// COMPLETING的持续时间非常短，只需要做一手现成的让步即可。</span></span><br><span class="line">            Thread.<span class="keyword">yield</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 现在线程的状态是NEW，（call方法可能还没执行完呢，准备挂起线程）</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 封装WaitNode存放当前线程</span></span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WaitNode</span>();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</span><br><span class="line">            <span class="comment">// 如果WaitNode还没有排在waiters中，现在就排进来（头插法的效果）</span></span><br><span class="line">            queued = UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q.next = waiters, q);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</span><br><span class="line">            <span class="comment">// get(time,unit)挂起线程的方式</span></span><br><span class="line">            <span class="comment">// 计算挂起时间</span></span><br><span class="line">            nanos = deadline - System.nanoTime();</span><br><span class="line">            <span class="comment">// 挂起的时间，是否小于等于0</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 移除waiters中的当前Node</span></span><br><span class="line">                removeWaiter(q);</span><br><span class="line">                <span class="comment">// 返回任务状态</span></span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 正常指定挂起时间即可。（线程挂起）</span></span><br><span class="line">            LockSupport.parkNanos(<span class="built_in">this</span>, nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// get()挂起线程的方式</span></span><br><span class="line">            LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线程挂起后，如果任务执行完毕，由finishCompletion唤醒线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 任务状态已经变为了NORMAL，做一些后续处理</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">finishCompletion</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="literal">null</span>;) &#123;</span><br><span class="line">        <span class="comment">// 拿到第一个节点后，直接用CAS的方式，将其设置为null</span></span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="built_in">this</span>, waitersOffset, q, <span class="literal">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 基于q拿到线程信息</span></span><br><span class="line">                <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> q.thread;</span><br><span class="line">                <span class="comment">// 线程不为null</span></span><br><span class="line">                <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 将WaitNode的thread设置为null</span></span><br><span class="line">                    q.thread = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// 唤醒这个线程</span></span><br><span class="line">                    LockSupport.unpark(t);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 往后遍历，接着唤醒</span></span><br><span class="line">                <span class="type">WaitNode</span> <span class="variable">next</span> <span class="operator">=</span> q.next;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                q.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 指向next的WaitNode</span></span><br><span class="line">                q = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扩展方法，没任何实现，你可以自己实现</span></span><br><span class="line">    done();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 任务处理完了，可以拜拜了！</span></span><br><span class="line">    callable = <span class="literal">null</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到返回结果的处理</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 任务结束。</span><br><span class="line">private V report(int s) throws ExecutionException &#123;</span><br><span class="line">    // 拿到结果</span><br><span class="line">    Object x = outcome;</span><br><span class="line">    // 判断是正常返回结束</span><br><span class="line">    if (s == NORMAL)</span><br><span class="line">        // 返回结果</span><br><span class="line">        return (V)x;</span><br><span class="line">    // 任务状态是大于取消</span><br><span class="line">    if (s &gt;= CANCELLED)</span><br><span class="line">        // 甩异常。</span><br><span class="line">        throw new CancellationException();</span><br><span class="line">    // 扔异常。</span><br><span class="line">    throw new ExecutionException((Throwable)x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 正常返回 report</span><br><span class="line">// 异常返回 report</span><br><span class="line">// 取消任务 report</span><br><span class="line">// 中断任务 awaitDone</span><br></pre></td></tr></table></figure>
<h2 id="四、牛批的CompletableFuture"><a href="#四、牛批的CompletableFuture" class="headerlink" title="四、牛批的CompletableFuture"></a>四、<strong>牛批的CompletableFuture</strong></h2><p>FutureTask存在的问题：<br>问题1：FutureTask获取线程执行的结果前，主线程需要通过get方法一直阻塞等待子线程执行完call方法，才可以拿到返回结果。<br>问题2：如果不通过get去挂起线程，通过while循环，不停的判断任务的执行状态是否结束，结束后，再拿结果。如果任务长时间没执行完毕，CPU会一直调度查看任务状态的方法，会浪费CPU资源。<br>FutureTask是一个同步非阻塞处理任务的方式。<br>需要一个异步非阻塞处理任务的方式。CompletableFuture在一定程度上就提供了各种异步非阻塞的处理方案，并且提供响应式编程，代码编写上，效果更佳（更漂亮）</p>
<p>CompletableFuture是JDK1.8，再次又Doug Lea研发，COmpletableFuture也是实现了Future接口实现的功能，可以不使用FutureTask，直接使用CompletableFuture即可。<br>提供非常丰富的函数去执行各种异步操作。</p>
<h1 id="十二、CompletableFuture应用"><a href="#十二、CompletableFuture应用" class="headerlink" title="十二、CompletableFuture应用"></a>十二、<strong>CompletableFuture应用</strong></h1><h2 id="回顾："><a href="#回顾：" class="headerlink" title="回顾："></a>回顾：</h2><blockquote>
<p>上次课，玩的FutureTask，应用起来特别简单。</p>
<p>FutureTask他是同步非阻塞。</p>
<p>FutureTask会配合Callable执行有返回结果的任务。</p>
<p>如果需要拿到返回结果，需要执行get方法，获取最终结果</p>
<p>因为无法实现异步非阻塞，JDK1.8中有个CompletableFuture可以实现<strong>异步非阻塞</strong>的效果</p>
<p>再带有返回结果的线程执行完毕后，提供一个回调。</p>
</blockquote>
<h2 id="一、CompletableFuture的应用"><a href="#一、CompletableFuture的应用" class="headerlink" title="一、CompletableFuture的应用"></a>一、CompletableFuture的应用</h2><p><strong>CompletableFuture最重要的就是解决了异步回调的问题</strong></p>
<p>CompletableFuture就是执行一个异步任务，异步任务可以有返回结果，也可以没有返回结果</p>
<p>CompletableFuture提供了两个最基本运行的基本方法</p>
<p>函数式编程中，三个最核心的接口</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Supplier - 生产者，没有入参，但是有返回结果</span><br><span class="line">Consumer - 消费者，有入参，但是没有返回结果</span><br><span class="line">Function - 函数，有入参，并且有返回结果</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>supplyAsync(Supplier&amp;#x3c;U&gt; supplier)</code></p>
<p>异步执行任务，有返回结果</p>
<p><code>runAsync(Runnable runnable)</code></p>
<p>异步执行任务，没有返回结果</p>
<p>在不指定线程池的前提下，这两个异步任务都是交给ForkJoinPool去执行的。</p>
<p>而ForkJoinPool内部是守护线程，守护线程在主线程结束后，就不干活了。</p>
</blockquote>
<p>但是只是用这两个方法，无法实现异步回调的。</p>
<p>如果需要在当前任务执行完毕后，拿着返回结果或者不拿返回结果，继续去执行后续任务操作的话，需要基于其他方法去实现</p>
<p><strong>这里的方法有个特点，都是在前置任务结果后，再执行当前任务</strong></p>
<blockquote>
<p>所以后续看的任务都有一个特点，大部分方法一共有三种方法重载、</p>
<p>不带Async，带Async，带Async还可以传入线程池的套路</p>
<hr>
<p><code>thenApply(Function&amp;#x3c;prevResult,currResult&gt;);</code></p>
<p>等待前一个任务处理结束后，拿着前置任务的返回结果，再做处理，并且返回当前结果</p>
<p><code>thenApplyAsync(Function&amp;#x3c;prevResult,currResult&gt;[,线程池])</code></p>
<p>跟上面的套路一致，但是再执行后续任务时，采用全新的线程执行</p>
<hr>
<p><code>thenAccept(Consumer&amp;#x3c;preResult&gt;);</code></p>
<p>等待前一个任务处理结束后，拿着前置任务的返回结果，再做处理，当然处理没有返回结果</p>
<p><code>thenAcceptAsync(Consumer&amp;#x3c;preResult&gt;[,线程池]);</code></p>
<p>跟上面的套路一致，但是再执行后续任务时，采用全新的线程执行</p>
<hr>
<p><code>thenRun(Runnable)</code></p>
<p>等待前一个任务处理结束后，再做处理。不接收前置任务结果，也不返回结果</p>
<p><code>thenRunAsync(Runnable[,线程池])</code></p>
<p>跟上面的套路一致，但是再执行后续任务时，采用全新的线程执行</p>
</blockquote>
<p>其次还有可以执行相对复杂的处理，在前一个任务执行的同时，执行后续任务。等待前置任务和后置任务都搞定之后，再执行最终任务</p>
<blockquote>
<p><code>thenCombine(CompletionStage,Function&amp;#x3c;prevResult,nextResult,afterResult&gt;)</code></p>
<p>可以让任务1和任务2一起执行，等待任务1和任务2全部搞定，获取前两个任务的结果执行最终处理，最终处理也可以返回结果<br><code>thenCombineAsync(CompletionStage,Function&amp;#x3c;prevResult,nextResult,afterResult&gt;[,线程池])</code></p>
<p>跟上面的套路一致，但是再执行后续任务时，采用全新的线程执行</p>
<p><code>thenAcceptBoth(CompletionStage,Consumer&amp;#x3c;prevResult,nextResult&gt;)</code></p>
<p>让前置任务和后续任务同时执行，都执行完毕后，拿到两个任务的结果，再做后续处理，但是没有返回结果</p>
<p><code>thenAcceptBothAsync(CompletionStage,Consumer&amp;#x3c;prevResult,nextResult&gt;[,线程池])</code></p>
<p>跟上面的套路一致，但是再执行后续任务时，采用全新的线程执行</p>
<p><code>runAfterBoth(CompletionStage,Runnble)</code></p>
<p>让前置任务和后续任务同时执行，都执行完毕后，再做后续处理</p>
<p><code>runAfterBothAsync(CompletionStage,Runnble[,线程池])</code></p>
<p>跟上面的套路一致，但是再执行后续任务时，采用全新的线程执行</p>
</blockquote>
<p>后面还提供了可以让两个任务一起执行，但是有一个任务结束，有返回结果后，就做最终处理</p>
<blockquote>
<p><code>applyToEither(CompletionStage,Function&amp;#x3c;firstResult,afterResult&gt;)</code></p>
<p>前面两个任务同时执行，有一个任务执行完，获取返回结果，做最终处理，再返回结果</p>
<p><code>acceptEither(CompletionStage,Consumer&amp;#x3c;firstResult&gt;)</code></p>
<p>前面两个任务同时执行，有一个任务执行完，获取返回结果，做最终处理</p>
<p><code>runAfterEither(CompletionStage,Runnable)</code></p>
<p>前面两个任务同时执行，有一个任务执行完，做最终处理</p>
<p>Async的不说了。</p>
</blockquote>
<p>后面还提供了等到前置任务处理完，再做后续处理，后续处理返回的结果为CompletionStage</p>
<blockquote>
<p><code>thenCompose(Function&amp;#x3c;prevResult,CompletionStage&gt;)</code></p>
<p>连接两个任务，前置处理完，执行后续，后续可以拿到前置任务的结果，并且做处理，最终返回的是CompletionStage</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thenCompose (Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">CompletionStage</span>&lt;U&gt;&gt; fn);</span><br><span class="line">thenApply   (Function&lt;? <span class="built_in">super</span> T, ? <span class="keyword">extends</span> <span class="title class_">U</span>&gt; fn);</span><br><span class="line"><span class="comment">// 用thenApply其实就足够了</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>最后还有处理异常的各种姿势</p>
<blockquote>
<p><code>exceptionally(Function&amp;#x3c;Throwable,currResult&gt;)</code></p>
<p>只有当前这个异常处理方法，可以获取到前面任务的异常信息，有异常才执行当前任务。</p>
<p>exceptionally不存在Async的操作。</p>
<p><code>whenComplete(Consumer&amp;#x3c;prevResult,Throwable&gt;)</code></p>
<p>可以拿到上一个任务的返回结果和异常，但是当前处理没有返回结果，无法影响最终让任务的结果内容</p>
<p>这个带有Async操作</p>
<p><code>hanle(Function&amp;#x3c;prevResult,Throwable,currResult&gt;)</code></p>
<p>可以拿到上一个任务的返回结果和异常，同时当前处理可以返回内容</p>
</blockquote>
<h2 id="二、基于上面阐述做应用"><a href="#二、基于上面阐述做应用" class="headerlink" title="二、基于上面阐述做应用"></a>二、基于上面阐述做应用</h2><h4 id="2-1-小一要回家干法，小二去做饭，小一看电视，等到小二昨晚，小一干饭。"><a href="#2-1-小一要回家干法，小二去做饭，小一看电视，等到小二昨晚，小一干饭。" class="headerlink" title="2.1 小一要回家干法，小二去做饭，小一看电视，等到小二昨晚，小一干饭。"></a>2.1 小一要回家干法，小二去做饭，小一看电视，等到小二昨晚，小一干饭。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sout(<span class="string">&quot;小连回家干饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sout(<span class="string">&quot;小严做饭！&quot;</span>);</span><br><span class="line">        sleep();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;锅包肉！&quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    sout(<span class="string">&quot;小连看电视！&quot;</span>);</span><br><span class="line"></span><br><span class="line">    sout(<span class="string">&quot;小连干饭：&quot;</span> + task.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-小一要回家干法，小二去炒菜，小三去焖饭，小一看电视，等到小二和小三都做好了，小四端菜和饭给小一，小一干饭"><a href="#2-2-小一要回家干法，小二去炒菜，小三去焖饭，小一看电视，等到小二和小三都做好了，小四端菜和饭给小一，小一干饭" class="headerlink" title="2.2 小一要回家干法，小二去炒菜，小三去焖饭，小一看电视，等到小二和小三都做好了，小四端菜和饭给小一，小一干饭"></a>2.2 小一要回家干法，小二去炒菜，小三去焖饭，小一看电视，等到小二和小三都做好了，小四端菜和饭给小一，小一干饭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    sout(<span class="string">&quot;小连回家干饭&quot;</span>);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;String&gt; task = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sout(<span class="string">&quot;小严去炒菜！&quot;</span>);</span><br><span class="line">        sleep();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;锅包肉！&quot;</span>;</span><br><span class="line">    &#125;,executor).thenCombineAsync(CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        sout(<span class="string">&quot;小李去焖饭&quot;</span>);</span><br><span class="line">        sleep();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;大米饭！&quot;</span>;</span><br><span class="line">    &#125;,executor),(food,rice) -&gt; &#123;</span><br><span class="line">        sout(<span class="string">&quot;小陈端&quot;</span> + food + <span class="string">&quot;,&quot;</span> + rice);</span><br><span class="line">        sleep();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;饭菜好了！&quot;</span>;</span><br><span class="line">    &#125;,executor);</span><br><span class="line"></span><br><span class="line">    sout(<span class="string">&quot;小连看电视！&quot;</span>);</span><br><span class="line">    sout(<span class="string">&quot;小连干饭：&quot;</span> + task.join());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="十三、CompletableFuture源码分析"><a href="#十三、CompletableFuture源码分析" class="headerlink" title="十三、CompletableFuture源码分析"></a>十三、<strong>CompletableFuture源码分析</strong></h1><p>异步回调</p>
<h2 id="一、runAsync方法源码分析"><a href="#一、runAsync方法源码分析" class="headerlink" title="一、runAsync方法源码分析"></a>一、runAsync方法源码分析</h2><p>基于当前这个最简单的方法，来分析CompletableFuture是如何执行异步任务的。</p>
<p>以及如何触发后续任务执行</p>
<h4 id="1-1-当前异步任务执行流程"><a href="#1-1-当前异步任务执行流程" class="headerlink" title="1.1 当前异步任务执行流程"></a>1.1 当前异步任务执行流程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步执行任务</span></span><br><span class="line"><span class="keyword">static</span> CompletableFuture&lt;Void&gt; <span class="title function_">asyncRunStage</span><span class="params">(Executor e, Runnable f)</span> &#123;</span><br><span class="line">    <span class="comment">// 非空判断。 </span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 声明当前任务的CompletableFuture对象</span></span><br><span class="line">    <span class="comment">// 在看CompletableFuture时，任务执行和后续任务的触发是两个操作</span></span><br><span class="line">    <span class="comment">// new的这个d，他的目的是为了触发后续任务的执行。</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;Void&gt;();</span><br><span class="line">    <span class="comment">// 将任务和CompletableFuture封装到一起，作为AsyncRun的对象</span></span><br><span class="line">    <span class="comment">// 将AsyncRun交给线程池执行</span></span><br><span class="line">    e.execute(<span class="keyword">new</span> <span class="title class_">AsyncRun</span>(d, f));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装任务和COmpletableFuture的AsyncRun对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AsyncRun</span> <span class="keyword">extends</span> <span class="title class_">ForkJoinTask</span>&lt;Void&gt; </span><br><span class="line">    CompletableFuture&lt;Void&gt; dep; Runnable fn;</span><br><span class="line">    <span class="comment">// 存储当前的任务以及CompletableFuture</span></span><br><span class="line">    AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123;</span><br><span class="line">        <span class="built_in">this</span>.dep = dep; <span class="built_in">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 声明两个变量，一个存储CompletableFuture，一个存储具体任务</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; d; Runnable f;</span><br><span class="line">        <span class="comment">// 非空判断的同时，将成员变量做临时存储</span></span><br><span class="line">        <span class="keyword">if</span> ((d = dep) != <span class="literal">null</span> &amp;&amp; (f = fn) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// help gc</span></span><br><span class="line">            dep = <span class="literal">null</span>; fn = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 当前任务是否已经有返回结果。</span></span><br><span class="line">            <span class="keyword">if</span> (d.result == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 任务还没有执行</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 线程池执行异步任务。</span></span><br><span class="line">                    f.run();</span><br><span class="line">                    <span class="comment">// 当然是Runnable任务，没有返回结果的，所以这里直接封装为一个表示null的标识</span></span><br><span class="line">                    <span class="comment">// 为null的结果是NIL</span></span><br><span class="line">                    d.completeNull();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="comment">// 如果异常结束，将出现的异常封装到返回结果中</span></span><br><span class="line">                    d.completeThrowable(ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 执行后续任务</span></span><br><span class="line">            d.postComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-后续任务的触发方式"><a href="#1-2-后续任务的触发方式" class="headerlink" title="1.2 后续任务的触发方式"></a>1.2 后续任务的触发方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前任务执行完毕，触发后续任务。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">postComplete</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// f：当前任务的COmpletableFuture</span></span><br><span class="line">    <span class="comment">// h：栈顶！</span></span><br><span class="line">    CompletableFuture&lt;?&gt; f = <span class="built_in">this</span>; Completion h;</span><br><span class="line">    <span class="comment">// h拿到栈顶数据。</span></span><br><span class="line">    <span class="keyword">while</span> ((h = f.stack) != <span class="literal">null</span> ||</span><br><span class="line">           (f != <span class="built_in">this</span> &amp;&amp; (h = (f = <span class="built_in">this</span>).stack) != <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 栈结构中有后续需要处理的任务，进到while循环中，每次循环之后，h的指针都会后移</span></span><br><span class="line">        CompletableFuture&lt;?&gt; d; Completion t;</span><br><span class="line">        <span class="comment">// 栈顶换人啦~~</span></span><br><span class="line">        <span class="keyword">if</span> (f.casStack(h, t = h.next)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f != <span class="built_in">this</span>) &#123;</span><br><span class="line">                    pushStack(h);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                h.next = <span class="literal">null</span>;    <span class="comment">// detach&#125;</span></span><br><span class="line">            <span class="comment">// 执行栈顶的任务</span></span><br><span class="line">            f = (d = h.tryFire(NESTED)) == <span class="literal">null</span> ? <span class="built_in">this</span> : d;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="">问题：发现CompletableFuture的后续任务是基于栈结构存储的，但是在测试的代码中，执行的顺序没有按照栈结构的方式，去执行</a></p>
<p><a href="">CompletableFuture不保证后续任务的执行顺序。</a></p>
<p>从上面的源码分析，发现，不会出现栈结构完全倒序的情况。</p>
<h2 id="二、thenRun方法源码分析"><a href="#二、thenRun方法源码分析" class="headerlink" title="二、thenRun方法源码分析"></a>二、thenRun方法源码分析</h2><p>后续任务的触发方式有两种：</p>
<ul>
<li>一种是基于前继任务执行完毕，执行postComplete方法触发</li>
<li>另一种是后续任务在压栈之前和之后，会尝试执行后续任务，只要前继任务执行结束的快，后续任务就可以直接执行，不需要前继任务的触发</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追加任务到栈结构的逻辑</span></span><br><span class="line"><span class="comment">// e：线程池、执行器。  如果是Async异步调用，会传递使用的线程池。 如果是普通的thenRun，不会传递线程池，为null</span></span><br><span class="line"><span class="keyword">private</span> CompletableFuture&lt;Void&gt; <span class="title function_">uniRunStage</span><span class="params">(Executor e, Runnable f)</span> &#123;</span><br><span class="line">    <span class="comment">// 阿巴阿巴。</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="comment">// 当前任务的CompletableFuture</span></span><br><span class="line">    CompletableFuture&lt;Void&gt; d = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;Void&gt;();</span><br><span class="line">    <span class="comment">// 如果传递了线程池，代表异步执行，直接走if代码块中的内容</span></span><br><span class="line">    <span class="comment">// 如果没有传递线程池，同步执行，需要先执行uniRun</span></span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> || !d.uniRun(<span class="built_in">this</span>, f, <span class="literal">null</span>)) &#123;</span><br><span class="line">        <span class="comment">// 前继任务还没执行完呢，那就准备压栈！</span></span><br><span class="line">        <span class="comment">// 将线程池，后续任务，前继任务，后续具体任务</span></span><br><span class="line">        UniRun&lt;T&gt; c = <span class="keyword">new</span> <span class="title class_">UniRun</span>&lt;T&gt;(e, d, <span class="built_in">this</span>, f);</span><br><span class="line">        <span class="comment">// 将封装好的c，直接到this的栈结构中</span></span><br><span class="line">        <span class="comment">// 不确保UniRun对象一定会被压到栈结构中</span></span><br><span class="line">        <span class="comment">// 在这个位置，可能会出现前继任务已经执行完毕，导致无法压到栈顶。</span></span><br><span class="line">        <span class="built_in">this</span>.push(c);</span><br><span class="line">        <span class="comment">// 尝试执行当前的后续任务</span></span><br><span class="line">        c.tryFire(SYNC);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前方法的作用：尝试执行任务。</span></span><br><span class="line"><span class="comment">// a：前继任务</span></span><br><span class="line"><span class="comment">// f：后续具体任务</span></span><br><span class="line"><span class="comment">// c：现在是null</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">uniRun</span><span class="params">(CompletableFuture&lt;?&gt; a, Runnable f, UniRun&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="comment">// 只看第二个判断。  </span></span><br><span class="line">    <span class="comment">// 如果前继任务没有执行完毕，直接return false</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || (r = a.result) == <span class="literal">null</span> || f == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 省略部分代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(UniCompletion&lt;?,?&gt; c)</span> &#123;</span><br><span class="line">    <span class="comment">// 不为null！！！</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// result是前继任务的结果</span></span><br><span class="line">        <span class="comment">// 只有前继任务还没有执行完毕时，才能将当前的UniRun对象压到栈结构中</span></span><br><span class="line">        <span class="keyword">while</span> (result == <span class="literal">null</span> &amp;&amp; !tryPushStack(c))</span><br><span class="line">            lazySetNext(c, <span class="literal">null</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续任务的执行，以及之前将后续任务封装的UniRun对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">UniRun</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">UniCompletion</span>&lt;T,Void&gt; &#123;</span><br><span class="line">    Runnable fn;</span><br><span class="line">    <span class="comment">// 之前封装后继任务调用的有参构造</span></span><br><span class="line">    UniRun(Executor executor, CompletableFuture&lt;Void&gt; dep,CompletableFuture&lt;T&gt; src, Runnable fn) &#123;</span><br><span class="line">        <span class="built_in">super</span>(executor, dep, src); <span class="built_in">this</span>.fn = fn;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试执行任务</span></span><br><span class="line">    <span class="comment">// dep：后续任务</span></span><br><span class="line">    <span class="comment">// src：前继任务</span></span><br><span class="line">    <span class="comment">// fn：后续具体任务</span></span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Void&gt; <span class="title function_">tryFire</span><span class="params">(<span class="type">int</span> mode)</span> &#123;</span><br><span class="line">        <span class="comment">// d：存储后续任务，   a：存储前继任务</span></span><br><span class="line">        CompletableFuture&lt;Void&gt; d; CompletableFuture&lt;T&gt; a;</span><br><span class="line">        <span class="keyword">if</span> ((d = dep) == <span class="literal">null</span> ||</span><br><span class="line">            <span class="comment">// 尝试执行后续任务的位置</span></span><br><span class="line">            !d.uniRun(a = src, fn, mode &gt; <span class="number">0</span> ? <span class="literal">null</span> : <span class="built_in">this</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dep = <span class="literal">null</span>; src = <span class="literal">null</span>; fn = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> d.postFire(a, mode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尝试执行后续任务的方法</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">uniRun</span><span class="params">(CompletableFuture&lt;?&gt; a, Runnable f, UniRun&lt;?&gt; c)</span> &#123;</span><br><span class="line">    Object r; Throwable x;</span><br><span class="line">    <span class="comment">// 判断前继任务执行完了么？ 如果执行完了，直接走后面执行后续任务</span></span><br><span class="line">    <span class="comment">// 如果前继任务没执行完，</span></span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">null</span> || (r = a.result) == <span class="literal">null</span> || f == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 到这，说明前继任务已经执行结束了。</span></span><br><span class="line">    <span class="comment">// 要执行后续任务，但是要先判断后续任务执行了么？  </span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 后续任务还木有执行</span></span><br><span class="line">        <span class="comment">// 如果前继任务是异常结束，后续任务就不需要执行了！</span></span><br><span class="line">        <span class="keyword">if</span> (r <span class="keyword">instanceof</span> AltResult &amp;&amp; (x = ((AltResult)r).ex) != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 正常封装异常信息。</span></span><br><span class="line">            completeThrowable(x, r);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 前继任务正常结束，尝试之后后续任务。</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果c == null，代表异步执行</span></span><br><span class="line">                <span class="comment">// 如果c != null，嵌套执行，同步执行</span></span><br><span class="line">                <span class="keyword">if</span> (c != <span class="literal">null</span> &amp;&amp; !c.claim())</span><br><span class="line">                    <span class="comment">// 异步执行完毕，返回false</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 需要同步执行</span></span><br><span class="line">                f.run();</span><br><span class="line">                <span class="comment">// 正常封装结果</span></span><br><span class="line">                completeNull();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="comment">// 异常封装结果</span></span><br><span class="line">                completeThrowable(ex);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">claim</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 拿到线程池</span></span><br><span class="line">    <span class="type">Executor</span> <span class="variable">e</span> <span class="operator">=</span> executor;</span><br><span class="line">    <span class="comment">// 判断当前任务标记，是否执行</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="type">short</span>)<span class="number">0</span>, (<span class="type">short</span>)<span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">// 线程池为null，代表同步执行，直接返回true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 异步执行，使用线程池执行即可。</span></span><br><span class="line">        executor = <span class="literal">null</span>; </span><br><span class="line">        e.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、整体执行流程图"><a href="#三、整体执行流程图" class="headerlink" title="三、整体执行流程图"></a>三、整体执行流程图</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/2746/1651751447066/fdede6efa1dd47d6a5308f9dabf9b658.png" alt="image.png"></p>
<h1 id="十四、并发编程总结"><a href="#十四、并发编程总结" class="headerlink" title="十四、并发编程总结"></a>十四、并发编程总结</h1><h2 id="一、锁"><a href="#一、锁" class="headerlink" title="一、锁"></a>一、锁</h2><h3 id="1-1-synchronized（看到Java层面就够了）"><a href="#1-1-synchronized（看到Java层面就够了）" class="headerlink" title="1.1 synchronized（看到Java层面就够了）"></a>1.1 synchronized（看到Java层面就够了）</h3><p><strong>对象锁和类锁</strong></p>
<p>synchronized到底是使用普通new出来的对象作为锁，还是Class对象作为锁</p>
<p>对象锁 - new多个对象去操作，无法实现互斥的</p>
<p>类锁 - 无论怎么使用，能保证一个JVM内是互斥的</p>
<p><strong>原理、对象头</strong></p>
<p>synchronized是基于对象作为锁的。</p>
<p>锁信息全部都放在了对象的对象头中的MarkWord中</p>
<p>其中线程竞争锁之前，肯定需要先查看当前锁的标记位，以不同的方式来竞争锁资源。</p>
<p><strong>锁升级</strong></p>
<ul>
<li><p>初始化状态的对象的锁信息有两种情况<strong>（无锁）</strong>：</p>
<ul>
<li>无锁状态：当前状态没有开启偏向锁。</li>
<li>匿名偏向：当前状态开启了偏向锁，没有偏向任何线程。</li>
</ul>
</li>
<li>偏向锁：只有一个线程来拿锁资源，没有竞争。</li>
<li>轻量级锁：以CAS的方式，去竞争锁资源，不会让线程挂起。（自适应自旋锁）（LockRecord）</li>
<li>重量级锁：直接采用MarkWord指向的ObjectMonitor以传统的方式去竞争锁资源。</li>
</ul>
<p><strong>偏向锁的重入是如何实现的？</strong></p>
<ul>
<li>其实偏向锁时，也用到了LockRecord，只不过内部不会存储hashcode信息等等，在偏向锁重入时，每次都会压栈一个LockRecord，从而实现偏向锁重入。</li>
</ul>
<p><strong>轻量级锁的CAS是如何实现的？</strong></p>
<ul>
<li><p>在重量级锁中实现的。基于TryLock方法采用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="type">void</span> * own = _owner ;</span><br><span class="line">      <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">         <span class="comment">// Either guarantee _recursions == 0 or set _recursions = 0.</span></span><br><span class="line">         <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="comment">// CONSIDER: set or assert that OwnerIsThread == 1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The lock had been free momentarily, but we lost the race to the lock.</span></span><br><span class="line">      <span class="comment">// Interference -- the CAS failed.</span></span><br><span class="line">      <span class="comment">// We can either return -1 or retry.</span></span><br><span class="line">      <span class="comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>synchronized和ReentrantLock后期更推荐使用谁。</strong></p>
<p>后期肯定是使用synchronized，因为synchronized底层更利于后期版本的优化，而ReentrantLock再怎么玩也是基于Java层面的锁。</p>
<p><strong>锁消除</strong></p>
<p>JMM层面在编译时，如果发展加锁的位置不存在任何的共享资源操作或者是引发线程安全问题的，那么去掉竞争和释放锁资源的操作。</p>
<p><strong>锁膨胀</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(xxx)&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">        <span class="comment">// 。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">    <span class="keyword">while</span>(xxx)&#123;</span><br><span class="line">        <span class="comment">// 。。。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-ReentrantLock"><a href="#1-2-ReentrantLock" class="headerlink" title="1.2 ReentrantLock"></a>1.2 ReentrantLock</h3><p>AQS：队列 + 状态位，就是一个JUC下的基础类，大量JUC下的并发工具都是基于AQS实现的。</p>
<p>状态位state：volatile修饰，CAS修改的int类型数值。</p>
<p>队列：双向链表。每个节点是一个Node。</p>
<p><strong>公平锁和非公平锁</strong></p>
<p>lock：非公平锁直接CAS修改state，如果失败，执行acquire。公平锁执行执行acquire。</p>
<p>tryAcquire：在发现state为0时。</p>
<ul>
<li>非公平锁，直接CAS修改state。</li>
<li>公平锁，查看队列中是否有排队的Node，如果有，查看head的next是不是当前线程，然后再决定是否CAS修改state</li>
</ul>
<p><strong>为什么唤醒Node时，要从后往前遍历找到离head最近的Node？</strong></p>
<p>在执行addWaiter方法时，先将当前Node的prev指向前一个节点，再将tail指向当前节点。此时上一个节点的next还有没有指向当前节点，如果存在并发问题，会导致遍历时，丢失节点。</p>
<h3 id="1-3-ReentrantReadWriteLock"><a href="#1-3-ReentrantReadWriteLock" class="headerlink" title="1.3 ReentrantReadWriteLock"></a>1.3 ReentrantReadWriteLock</h3><p><strong>读写锁实现实现原理</strong></p>
<p>还是基于AQS实现的，将state的高16位作为读锁的信息，低16位作为写锁的信息。</p>
<p>读锁是共享锁。写锁是互斥锁。</p>
<p><strong>如何避免写锁饥饿的</strong></p>
<p>读锁获取锁资源时，判断当前在AQS中排队的是否是写锁资源，如果是写锁，读锁会直接在AQS中排队</p>
<p><strong>读锁重入如何实现</strong></p>
<p>读锁可能会有多个线程同时持有，如果不清楚每个线程重入的次数，无法确定读锁资源是否释放干净。</p>
<p>ReentrantReadWriteLock就基于ThreadLocal来记录当前线程读锁重入的次数。</p>
<p>当然，同时也要对state的高16位，进行修改。</p>
<p><strong>读锁重入的优化</strong></p>
<p>第一个持有读锁的线程，无需将重入次数设置到ThreadLocal中，直接使用读写锁内部提供的firstReader来记录当前线程，采用firstReaderHoldCount来记录读锁重入的次数。</p>
<p>最后一个来竞争读锁资源的线程（不包含第一个），采用cachedHoldCounter来记录锁重入次数，也会在ThreadLocal中存储一份，但是如果当前线程再次重入，不需要从ThreadLocal中获取，而是直接修改cachedHoldCounter即可</p>
<h2 id="二、ThreadPoolExecutor"><a href="#二、ThreadPoolExecutor" class="headerlink" title="二、ThreadPoolExecutor"></a>二、ThreadPoolExecutor</h2><p><strong>线程池的7个核心参数</strong></p>
<p>不会的，出门左转。</p>
<p><strong>线程池的拒绝策略</strong></p>
<p>线程池自带四种，如何可以满足业务需求，直接用即可，如果不满足，可以自行实现RejectedExecutionHandler接口，重写功能。</p>
<p><strong>线程池的状态</strong></p>
<p>RUNNING，SHOTDOWN，STOP，TIDYING，TERMINATED</p>
<p>TIDYING是过渡状态，可以从SHUTDOWN和STOP状态转换过来，其实到了TIDYING，工作线程已经没了，工作队列的任务也处理完了。就差执行一个terminated方法，转换到TERMINATED状态</p>
<p><strong>线程池的ctl属性</strong></p>
<p>高3位存储线程池状态，低29位存储工作线程个数。</p>
<p><strong>线程池的执行流程</strong></p>
<p>不会的，出门右转。</p>
<p><strong>为什么线程池要添加非核心并且没有任务的工作线程addWroker(null,false);</strong></p>
<p>当前工作线程个数为0，但是工作队列中有任务</p>
<p>此时就需要添加一个非核心并且空任务的工作线程去处理阻塞队列中的任务</p>
<p><strong>Worker中的锁是干嘛的</strong></p>
<p>Worker中基于AQS实现了一个非可重入锁。</p>
<p>Worker为了避免中断线程时，Worker还没有初始化完成，导致出现问题。</p>
<p><strong>如何在线程池之前任务前后做额外处理</strong></p>
<p>线程池提供了两个勾子函数。</p>
<h2 id="三、ConcurrentHashMap（1-8）"><a href="#三、ConcurrentHashMap（1-8）" class="headerlink" title="三、ConcurrentHashMap（1.8）"></a>三、ConcurrentHashMap（1.8）</h2><p><strong>ConcurrentHashMap在JDK1.8中如何实现线程安全</strong></p>
<p>阿巴阿巴……</p>
<p><strong>ConcurrentHashMap的散列算法</strong></p>
<p>阿巴阿巴……</p>
<p><strong>ConcurrentHashMap的数组长度为何是2的n次幂</strong></p>
<p>阿巴阿巴……</p>
<p><strong>ConcurrentHashMap如何实现并发扩容的</strong></p>
<p>resizeStamp，sizeCtl，扩容线程数 + 1</p>
<p><strong>ConcurrentHashMap中的addCount如何实现</strong></p>
<p>addCount在记录ConcurrentHashMap中元素的个数，因为AtomicLong在高并发情况下，性能较低，所以ConcurrentHashMap中采用了LongAdder的实现方式，其实就是将LongAdder的源码，复制过来改了一改。并且在addCount方法中，还会有扩容的判断。</p>
<p><strong>ConcurrentHashMap红黑树什么情况会转换为链表</strong></p>
<p>扩容时，或者删除红黑树数据长度小于等于6时，都有可能将红黑树转为链表</p>
<p><strong>ConcurrentHashMap在有线程写红黑树时，读操作怎么办</strong></p>
<p>链表在扩容为红黑树的同时，会保留双向链表和红黑树。</p>
<p>此时会查询双向链表，不会查询红黑树。</p>
<p><strong>ConcurrentHashMap的lastRun机制是什么</strong></p>
<p>阿巴阿巴……</p>
<h2 id="四、并发工具"><a href="#四、并发工具" class="headerlink" title="四、并发工具"></a>四、并发工具</h2><h3 id="4-1-CountDownLatch"><a href="#4-1-CountDownLatch" class="headerlink" title="4.1 CountDownLatch"></a>4.1 CountDownLatch</h3><p><strong>CountDownLatch实现原理</strong></p>
<p>CountDownLatch基于AQS实现的，初始化时给定一个state的值。</p>
<p>每次线程执行countDown方法时，对state - 1。</p>
<p>如果线程在执行await方法时：</p>
<ul>
<li>state &gt; 0，此时线程挂起</li>
<li>state == 0，此时线程被唤醒</li>
</ul>
<h3 id="4-2-Semaphore"><a href="#4-2-Semaphore" class="headerlink" title="4.2 Semaphore"></a>4.2 Semaphore</h3><p><strong>Semaphore实现原理</strong></p>
<p>还是基于AQS实现的，一般用于固定资源，比如连接池，线程池等等。</p>
<p>类似计数器。每次从线程中基于acquire拿到资源，使用完毕后，基于release归还资源。</p>
<p><strong>PROPAGATE类型Node的作用</strong></p>
<p>因为在JDK1.5中，Semaphore存在资源无法被正常使用的情况。</p>
<p>信号量中有资源，但是线程通过acquire无法获取</p>
<p>基于PROPAGATE类型的Node，可以在唤醒当前线程后，继续唤醒后续线程</p>
<h3 id="4-3-CyclicBarrier"><a href="#4-3-CyclicBarrier" class="headerlink" title="4.3 CyclicBarrier"></a>4.3 CyclicBarrier</h3><p><strong>CyclicBarrier实现原理</strong></p>
<p>Java中的栅栏</p>
<p>类似CountDownLatch的原理，等待指定数量的线程执行await方法后，一起并行去执行这些线程的后续任务。</p>
<p>CyclicBarrier是可以重置state的，也就是任务执行一次后，可以重新反复使用当前的CyclicBarrier</p>
<p><strong>ReentrantLock的Condition的实现原理</strong></p>
<p>当线程获取到锁资源后，基于Condition挂起线程时，会释放锁资源，并且将当前线程封装到AQS中的Condition中的一个链表中，当基于signal方法唤醒后，会扔到AQS的双向链表中</p>
<h2 id="5、阻塞队列"><a href="#5、阻塞队列" class="headerlink" title="5、阻塞队列"></a>5、阻塞队列</h2><h3 id="5-1-ArrayBlockingQueue"><a href="#5-1-ArrayBlockingQueue" class="headerlink" title="5.1 ArrayBlockingQueue"></a>5.1 ArrayBlockingQueue</h3><p>基于数组实现的阻塞队列</p>
<p><strong>虚假唤醒</strong></p>
<p>在await挂起线程判断的位置，采用while循环去解决虚假唤醒。</p>
<p>如果使用if判断，会造成多个线程在不满足情况下，去向阻塞队列追加数据，导致安全问题。、</p>
<h3 id="5-2-LinkedBlockingQueue"><a href="#5-2-LinkedBlockingQueue" class="headerlink" title="5.2 LinkedBlockingQueue"></a>5.2 LinkedBlockingQueue</h3><p>基于链表实现的阻塞队列</p>
<h3 id="5-3-PriorityQueue"><a href="#5-3-PriorityQueue" class="headerlink" title="5.3 PriorityQueue"></a>5.3 PriorityQueue</h3><p>基于数组实现的二叉堆，基于二叉堆实现的优先级队列</p>
<h3 id="5-4-PriorityBlockingQueue"><a href="#5-4-PriorityBlockingQueue" class="headerlink" title="5.4 PriorityBlockingQueue"></a>5.4 PriorityBlockingQueue</h3><p>基于PriorityQueue实现的阻塞队列</p>
<h3 id="5-5-DelayedQueue"><a href="#5-5-DelayedQueue" class="headerlink" title="5.5 DelayedQueue"></a>5.5 DelayedQueue</h3><p>基于PriorityQueue实现的延迟队列，要求插入的数据要实现Delayed接口。</p>
<h3 id="5-6-SynchronousQueue"><a href="#5-6-SynchronousQueue" class="headerlink" title="5.6 SynchronousQueue"></a>5.6 SynchronousQueue</h3><p>不会将数组存放到指定位置，生产者放数据，就要一直等到消费者来消费。</p>
<h2 id="6、ScheduleThreadPoolExecutor"><a href="#6、ScheduleThreadPoolExecutor" class="headerlink" title="6、ScheduleThreadPoolExecutor"></a>6、ScheduleThreadPoolExecutor</h2><p><strong>execute，schedule，scheduleAtFixedRate，scheduleWithFixedDelay的区别</strong></p>
<ul>
<li>execute：正常执行任务，跟定时执行没关系。</li>
<li>schedule：延迟一段时间执行。执行一次。</li>
<li>scheduleAtFixedRate：可以让任务在固定的周期下执行。（如果任务执行时间，超过了延迟时间，采用任务的执行时间作为周期）这里会采用上次任务执行的时间点，加上延迟时间，作为下次任务的时间</li>
<li>scheduleWithFixedDelay：可以让任务在固定的周期下执行。（任务的处理时间，影响下次执行时间）</li>
</ul>
<h2 id="7、CompletableFuture"><a href="#7、CompletableFuture" class="headerlink" title="7、CompletableFuture"></a>7、CompletableFuture</h2><p><strong>CompletableFuture是什么</strong></p>
<p>实现了异步非阻塞的效果。就是在任务执行完毕后，会主动通知，不需要调用方主动会获取。</p>
<p><strong>CompletableFuture的后续任务是基于什么存储的</strong></p>
<p>栈</p>
<p><strong>CompletableFuture为何不能保证后续任务的执行顺序</strong></p>
<p>因为任务是其他线程执行，业务线程依然可以给CompletableFuture设置后续任务，如果在设置任务到栈结构之前，前置任务已经执行完了，就不需要再存放到栈结构了，直接执行即可。</p>
<p><strong>如果有时间，一定要系统的看一下源码，这样依赖八股文什么的就不用看了。</strong></p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s21.ax1x.com/2025/07/10/pVQs3JU.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s21.ax1x.com/2025/07/10/pVQs3JU.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">Wizard小志</div><div class="post-copyright__author_desc">I'm iron man</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://yanruizhi.github.io/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://yanruizhi.github.io/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/')">并发编程</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://yanruizhi.github.io/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=并发编程&amp;url=https://yanruizhi.github.io/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&amp;pic=https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://yanruizhi.github.io" target="_blank">Wizard</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/%E9%9D%A2%E8%AF%95/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>面试<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp" data-sites="qzone,qq,wechat,weibo,douban"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2025/07/09/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MarkDown基础语法</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="anzhiyufont anzhiyu-icon-comments"></i><span> 评论</span></div><div class="comment-randomInfo"><a onclick="anzhiyu.addRandomCommentInfo()" href="javascript:void(0)">匿名评论</a><a href="/privacy" style="margin-left: 4px">隐私政策</a></div><div class="comment-tips" id="comment-tips"><span>✅ 你无需删除空行，直接评论以获取最佳展示效果</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div><div class="comment-barrage"></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s21.ax1x.com/2025/07/10/pVQs3JU.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/icon/056.png" alt="status"/></div></div><div class="author-info__description">生命不息，折腾不止</div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Wizard小志</h1><div class="author-info__desc">I'm iron man</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/yanruizhi" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/52917260" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">一、并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.1.</span> <span class="toc-text">并发编程三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E6%9C%89%E5%BA%8F%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">一、原子性、有序性、可见性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1 原子性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.2 有序性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3 可见性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81synchronized%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">二、synchronized使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-synchronized%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1 synchronized的使用方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81synchronized%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">1.1.3.</span> <span class="toc-text">三、synchronized锁升级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81synchronized-ObjectMonitor"><span class="toc-number">1.1.4.</span> <span class="toc-text">四、synchronized-ObjectMonitor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ReentrantLock%E6%BA%90%E7%A0%81"><span class="toc-number">2.</span> <span class="toc-text">二、ReentrantLock源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ReentrantLock%E4%BB%8B%E7%BB%8D"><span class="toc-number">2.0.1.</span> <span class="toc-text">一、ReentrantLock介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ReentrantLock%E7%9A%84lock%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81"><span class="toc-number">2.0.2.</span> <span class="toc-text">二、ReentrantLock的lock方法源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81ReentrantLock%E7%9A%84acquire%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81"><span class="toc-number">2.0.3.</span> <span class="toc-text">三、ReentrantLock的acquire方法源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81ReentrantLock%E7%9A%84tryAcquire%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.4.</span> <span class="toc-text">四、ReentrantLock的tryAcquire方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81ReentrantLock%E7%9A%84addWaiter%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.5.</span> <span class="toc-text">五、ReentrantLock的addWaiter方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81ReentrantLock%E7%9A%84acquireQueued"><span class="toc-number">2.0.6.</span> <span class="toc-text">六、ReentrantLock的acquireQueued</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81ReentrantLock%E7%9A%84unlock%E6%96%B9%E6%B3%95"><span class="toc-number">2.0.7.</span> <span class="toc-text">七、ReentrantLock的unlock方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81ReentrantReadWriteLock%E8%AF%BB%E5%86%99%E9%94%81%E6%BA%90%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">三、ReentrantReadWriteLock读写锁源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%87%BA%E7%8E%B0%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.0.1.</span> <span class="toc-text">一、为什么要出现读写锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">3.0.2.</span> <span class="toc-text">二、读写锁的核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%99%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.3.</span> <span class="toc-text">三、写锁的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%86%99%E9%94%81%E5%8A%A0%E9%94%81-acquire"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">3.1 写锁加锁-acquire</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%A9%E4%B8%8B%E7%9A%84addWaiter%E5%92%8CacquireQueued%E5%92%8CReentrantLock%E7%9C%8B%E7%9A%84%E4%B8%80%E6%A0%B7%EF%BC%8C%E9%83%BD%E6%98%AFAQS%E8%87%AA%E8%BA%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.0.3.1.1.</span> <span class="toc-text">剩下的addWaiter和acquireQueued和ReentrantLock看的一样，都是AQS自身提供的方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%86%99%E9%94%81-%E9%87%8A%E6%94%BE%E9%94%81%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">3.2 写锁-释放锁操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E8%AF%BB%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.4.</span> <span class="toc-text">四、读锁的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E8%AF%BB%E9%94%81%E7%9A%84%E5%8A%A0%E9%94%81%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">4.1 读锁的加锁操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%8A%A0%E9%94%81-%E6%89%94%E5%88%B0%E9%98%9F%E5%88%97%E5%87%86%E5%A4%87%E9%98%BB%E5%A1%9E%E6%93%8D%E4%BD%9C"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">4.2 加锁-扔到队列准备阻塞操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%BA%90%E7%A0%81"><span class="toc-number">4.</span> <span class="toc-text">四、线程池源码</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%8B%E7%BB%8D"><span class="toc-number">4.0.1.</span> <span class="toc-text">一、线程池介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7%E8%AE%A4%E7%9F%A5"><span class="toc-number">4.0.2.</span> <span class="toc-text">二、线程池核心属性认知</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81execute%E6%96%B9%E6%B3%95"><span class="toc-number">4.0.3.</span> <span class="toc-text">三、execute方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81addWorker%E6%B7%BB%E5%8A%A0%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.0.4.</span> <span class="toc-text">四、addWorker添加工作线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81runWorker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.0.5.</span> <span class="toc-text">五、runWorker执行任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81getTask%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E6%8E%92%E9%98%9F%E6%8B%BF%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.0.6.</span> <span class="toc-text">六、getTask工作线程排队拿任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81processWorkerExit%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E5%91%8A%E8%BE%9E"><span class="toc-number">4.0.7.</span> <span class="toc-text">七、processWorkerExit工作线程告辞~</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81ConcurrentHashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89"><span class="toc-number">5.</span> <span class="toc-text">五、ConcurrentHashMap源码分析（一）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%93%E6%9E%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">5.0.1.</span> <span class="toc-text">一、结构介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95"><span class="toc-number">5.0.2.</span> <span class="toc-text">二、散列算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">5.0.3.</span> <span class="toc-text">三、初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE-%E6%95%B0%E7%BB%84"><span class="toc-number">5.0.4.</span> <span class="toc-text">四、添加数据-数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE-%E9%93%BE%E8%A1%A8"><span class="toc-number">5.0.5.</span> <span class="toc-text">五、添加数据-链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E8%A7%A6%E5%8F%91%E6%89%A9%E5%AE%B9"><span class="toc-number">5.0.6.</span> <span class="toc-text">六、触发扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E3%80%81HashMap%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">5.0.7.</span> <span class="toc-text">七、HashMap的扩容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81ConcurrentHashMap%E6%89%A9%E5%AE%B9"><span class="toc-number">6.</span> <span class="toc-text">六、ConcurrentHashMap扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81tryPreSize%E6%96%B9%E6%B3%95-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">6.0.1.</span> <span class="toc-text">一、tryPreSize方法-初始化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81tryPreSize%E6%96%B9%E6%B3%95-%E6%89%A9%E5%AE%B9%E6%A0%87%E8%AF%86%E6%88%B3"><span class="toc-number">6.0.2.</span> <span class="toc-text">二、tryPreSize方法-扩容标识戳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81transfer%E6%96%B9%E6%B3%95-%E6%9E%84%E5%BB%BA%E6%96%B0%E6%95%B0%E7%BB%84"><span class="toc-number">6.0.3.</span> <span class="toc-text">三、transfer方法-构建新数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81transfer%E6%96%B9%E6%B3%95-%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">6.0.4.</span> <span class="toc-text">四、transfer方法-迁移数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81transfer%E6%96%B9%E6%B3%95-lastRun%E6%9C%BA%E5%88%B6"><span class="toc-number">6.0.5.</span> <span class="toc-text">五、transfer方法-lastRun机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81helpTransfer%E6%96%B9%E6%B3%95-%E5%8D%8F%E5%8A%A9%E6%89%A9%E5%AE%B9"><span class="toc-number">6.0.6.</span> <span class="toc-text">六、helpTransfer方法-协助扩容</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81JUC%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">7.</span> <span class="toc-text">七、JUC并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81CountDownLatch%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.1.</span> <span class="toc-text">一、CountDownLatch应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81CountDownLatch%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.0.2.</span> <span class="toc-text">二、CountDownLatch核心源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BB%8E%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%9F%A5%E7%9C%8B"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">2.1 从构造方法查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-countDown%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">2.2 countDown方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-await%E6%96%B9%E6%B3%95"><span class="toc-number">7.0.2.3.</span> <span class="toc-text">2.3 await方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81Semaphore%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.3.</span> <span class="toc-text">三、Semaphore应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Semaphore%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.0.4.</span> <span class="toc-text">四、Semaphore核心源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">4.1 有参构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-acquire"><span class="toc-number">7.0.4.2.</span> <span class="toc-text">4.2 acquire</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-release"><span class="toc-number">7.0.4.3.</span> <span class="toc-text">4.3 release</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%88%86%E6%9E%90AQS%E4%B8%ADPROPAGATE%E7%B1%BB%E5%9E%8B%E8%8A%82%E7%82%B9%EF%BC%88%E5%94%AF%E4%B8%80%E7%9A%84%E9%9A%BE%E7%82%B9%EF%BC%89"><span class="toc-number">7.0.4.4.</span> <span class="toc-text">4.4 分析AQS中PROPAGATE类型节点（唯一的难点）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81CyclicBarrier%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.5.</span> <span class="toc-text">五、CyclicBarrier应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E3%80%81CyclicBarrier%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">7.0.6.</span> <span class="toc-text">六、CyclicBarrier核心源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%9C%89%E5%8F%82%E6%9E%84%E9%80%A0"><span class="toc-number">7.0.6.1.</span> <span class="toc-text">6.1 有参构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-await"><span class="toc-number">7.0.6.2.</span> <span class="toc-text">6.2 await</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81JUC%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">8.</span> <span class="toc-text">八、JUC阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ArrayBlockingQueue"><span class="toc-number">8.0.1.</span> <span class="toc-text">一、ArrayBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-ArrayBlockingQueue%E5%BA%94%E7%94%A8"><span class="toc-number">8.0.1.1.</span> <span class="toc-text">1.1 ArrayBlockingQueue应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%AD%98%E6%95%B0%E6%8D%AE%E6%BA%90%E7%A0%81"><span class="toc-number">8.0.1.2.</span> <span class="toc-text">1.2 存数据源码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">8.0.1.3.</span> <span class="toc-text">1.3 取数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81LinkedBlockingQueue"><span class="toc-number">8.0.2.</span> <span class="toc-text">二、LinkedBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">8.0.2.1.</span> <span class="toc-text">2.1 写操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">8.0.2.2.</span> <span class="toc-text">2.2 读操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81PriorityQueue"><span class="toc-number">8.0.3.</span> <span class="toc-text">三、PriorityQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%B7%BB%E5%8A%A0%E6%93%8D%E4%BD%9C%E4%B8%8A%E7%A7%BB%E4%BF%9D%E8%AF%81%E7%BB%93%E6%9E%84"><span class="toc-number">8.0.3.1.</span> <span class="toc-text">3.1 添加操作上移保证结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E5%8F%96%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BA%8C%E5%8F%89%E5%A0%86%E7%BB%93%E6%9E%84"><span class="toc-number">8.0.3.2.</span> <span class="toc-text">3.2 取数据如何保证二叉堆结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81PriorityBlockingQueue"><span class="toc-number">8.0.4.</span> <span class="toc-text">四、PriorityBlockingQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%86%99%E6%93%8D%E4%BD%9C"><span class="toc-number">8.0.4.1.</span> <span class="toc-text">4.1 写操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%AF%BB%E6%93%8D%E4%BD%9C"><span class="toc-number">8.0.4.2.</span> <span class="toc-text">4.2 读操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81JUC%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%AC%AC%E4%BA%8C%E5%BC%B9"><span class="toc-number">9.</span> <span class="toc-text">九、JUC阻塞队列第二弹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81DelayQueue"><span class="toc-number">9.0.1.</span> <span class="toc-text">一、DelayQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%8E%8C%E6%8F%A1DelayQueue%E5%BA%94%E7%94%A8"><span class="toc-number">9.0.1.1.</span> <span class="toc-text">1.1 掌握DelayQueue应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%88%86%E6%9E%90%E6%BA%90%E7%A0%81"><span class="toc-number">9.0.1.2.</span> <span class="toc-text">1.2 分析源码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81SynchronousQueue"><span class="toc-number">9.0.2.</span> <span class="toc-text">二、SynchronousQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E4%BB%8B%E7%BB%8D-amp-%E5%BA%94%E7%94%A8"><span class="toc-number">9.0.2.1.</span> <span class="toc-text">2.1 介绍&amp;应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9"><span class="toc-number">9.0.2.2.</span> <span class="toc-text">2.1 核心内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%89%A7%E8%A1%8C%E5%A5%97%E8%B7%AF"><span class="toc-number">9.0.2.3.</span> <span class="toc-text">2.3 生产者和消费者执行套路</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E3%80%81ScheduledThreadPoolExecutor"><span class="toc-number">10.</span> <span class="toc-text">十、ScheduledThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81ScheduledThreadPoolExecutor%E4%BB%8B%E7%BB%8D-amp-%E5%BA%94%E7%94%A8"><span class="toc-number">10.0.1.</span> <span class="toc-text">一、ScheduledThreadPoolExecutor介绍&amp;应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ScheduleThreadPoolExecutor%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">10.0.2.</span> <span class="toc-text">二、ScheduleThreadPoolExecutor底层结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-ScheduledFutureTask"><span class="toc-number">10.0.2.1.</span> <span class="toc-text">2.1 ScheduledFutureTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-DelayedWorkQueue"><span class="toc-number">10.0.2.2.</span> <span class="toc-text">2.2 DelayedWorkQueue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81execute%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">10.0.3.</span> <span class="toc-text">三、execute方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81schedule%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">10.0.4.</span> <span class="toc-text">四、schedule方法分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81scheduleAtFixedRate%E5%92%8CscheduleWithFixedDelay%E5%88%86%E6%9E%90"><span class="toc-number">10.0.5.</span> <span class="toc-text">五、scheduleAtFixedRate和scheduleWithFixedDelay分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81FutureTask%E6%BA%90%E7%A0%81"><span class="toc-number">11.</span> <span class="toc-text">十一、FutureTask源码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Future%E4%BB%8B%E7%BB%8D"><span class="toc-number">11.1.</span> <span class="toc-text">一、Future介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81FutureTask%E4%BD%BF%E7%94%A8"><span class="toc-number">11.2.</span> <span class="toc-text">二、FutureTask使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81FutureTask%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">11.3.</span> <span class="toc-text">三、FutureTask源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E7%89%9B%E6%89%B9%E7%9A%84CompletableFuture"><span class="toc-number">11.4.</span> <span class="toc-text">四、牛批的CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81CompletableFuture%E5%BA%94%E7%94%A8"><span class="toc-number">12.</span> <span class="toc-text">十二、CompletableFuture应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%EF%BC%9A"><span class="toc-number">12.1.</span> <span class="toc-text">回顾：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81CompletableFuture%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">12.2.</span> <span class="toc-text">一、CompletableFuture的应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9F%BA%E4%BA%8E%E4%B8%8A%E9%9D%A2%E9%98%90%E8%BF%B0%E5%81%9A%E5%BA%94%E7%94%A8"><span class="toc-number">12.3.</span> <span class="toc-text">二、基于上面阐述做应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E5%B0%8F%E4%B8%80%E8%A6%81%E5%9B%9E%E5%AE%B6%E5%B9%B2%E6%B3%95%EF%BC%8C%E5%B0%8F%E4%BA%8C%E5%8E%BB%E5%81%9A%E9%A5%AD%EF%BC%8C%E5%B0%8F%E4%B8%80%E7%9C%8B%E7%94%B5%E8%A7%86%EF%BC%8C%E7%AD%89%E5%88%B0%E5%B0%8F%E4%BA%8C%E6%98%A8%E6%99%9A%EF%BC%8C%E5%B0%8F%E4%B8%80%E5%B9%B2%E9%A5%AD%E3%80%82"><span class="toc-number">12.3.0.1.</span> <span class="toc-text">2.1 小一要回家干法，小二去做饭，小一看电视，等到小二昨晚，小一干饭。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%B0%8F%E4%B8%80%E8%A6%81%E5%9B%9E%E5%AE%B6%E5%B9%B2%E6%B3%95%EF%BC%8C%E5%B0%8F%E4%BA%8C%E5%8E%BB%E7%82%92%E8%8F%9C%EF%BC%8C%E5%B0%8F%E4%B8%89%E5%8E%BB%E7%84%96%E9%A5%AD%EF%BC%8C%E5%B0%8F%E4%B8%80%E7%9C%8B%E7%94%B5%E8%A7%86%EF%BC%8C%E7%AD%89%E5%88%B0%E5%B0%8F%E4%BA%8C%E5%92%8C%E5%B0%8F%E4%B8%89%E9%83%BD%E5%81%9A%E5%A5%BD%E4%BA%86%EF%BC%8C%E5%B0%8F%E5%9B%9B%E7%AB%AF%E8%8F%9C%E5%92%8C%E9%A5%AD%E7%BB%99%E5%B0%8F%E4%B8%80%EF%BC%8C%E5%B0%8F%E4%B8%80%E5%B9%B2%E9%A5%AD"><span class="toc-number">12.3.0.2.</span> <span class="toc-text">2.2 小一要回家干法，小二去炒菜，小三去焖饭，小一看电视，等到小二和小三都做好了，小四端菜和饭给小一，小一干饭</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81CompletableFuture%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">13.</span> <span class="toc-text">十三、CompletableFuture源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81runAsync%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">13.1.</span> <span class="toc-text">一、runAsync方法源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%BD%93%E5%89%8D%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">13.1.0.1.</span> <span class="toc-text">1.1 当前异步任务执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E5%90%8E%E7%BB%AD%E4%BB%BB%E5%8A%A1%E7%9A%84%E8%A7%A6%E5%8F%91%E6%96%B9%E5%BC%8F"><span class="toc-number">13.1.0.2.</span> <span class="toc-text">1.2 后续任务的触发方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81thenRun%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">13.2.</span> <span class="toc-text">二、thenRun方法源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%95%B4%E4%BD%93%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">13.3.</span> <span class="toc-text">三、整体执行流程图</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">14.</span> <span class="toc-text">十四、并发编程总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%94%81"><span class="toc-number">14.1.</span> <span class="toc-text">一、锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-synchronized%EF%BC%88%E7%9C%8B%E5%88%B0Java%E5%B1%82%E9%9D%A2%E5%B0%B1%E5%A4%9F%E4%BA%86%EF%BC%89"><span class="toc-number">14.1.1.</span> <span class="toc-text">1.1 synchronized（看到Java层面就够了）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-ReentrantLock"><span class="toc-number">14.1.2.</span> <span class="toc-text">1.2 ReentrantLock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-ReentrantReadWriteLock"><span class="toc-number">14.1.3.</span> <span class="toc-text">1.3 ReentrantReadWriteLock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81ThreadPoolExecutor"><span class="toc-number">14.2.</span> <span class="toc-text">二、ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ConcurrentHashMap%EF%BC%881-8%EF%BC%89"><span class="toc-number">14.3.</span> <span class="toc-text">三、ConcurrentHashMap（1.8）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-number">14.4.</span> <span class="toc-text">四、并发工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-CountDownLatch"><span class="toc-number">14.4.1.</span> <span class="toc-text">4.1 CountDownLatch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Semaphore"><span class="toc-number">14.4.2.</span> <span class="toc-text">4.2 Semaphore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-CyclicBarrier"><span class="toc-number">14.4.3.</span> <span class="toc-text">4.3 CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">14.5.</span> <span class="toc-text">5、阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-ArrayBlockingQueue"><span class="toc-number">14.5.1.</span> <span class="toc-text">5.1 ArrayBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-LinkedBlockingQueue"><span class="toc-number">14.5.2.</span> <span class="toc-text">5.2 LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-PriorityQueue"><span class="toc-number">14.5.3.</span> <span class="toc-text">5.3 PriorityQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-PriorityBlockingQueue"><span class="toc-number">14.5.4.</span> <span class="toc-text">5.4 PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-DelayedQueue"><span class="toc-number">14.5.5.</span> <span class="toc-text">5.5 DelayedQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-SynchronousQueue"><span class="toc-number">14.5.6.</span> <span class="toc-text">5.6 SynchronousQueue</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81ScheduleThreadPoolExecutor"><span class="toc-number">14.6.</span> <span class="toc-text">6、ScheduleThreadPoolExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81CompletableFuture"><span class="toc-number">14.7.</span> <span class="toc-text">7、CompletableFuture</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="并发编程"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="并发编程"/></a><div class="content"><a class="title" href="/2025/07/10/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" title="并发编程">并发编程</a><time datetime="2025-07-09T16:00:00.000Z" title="发表于 2025-07-10 00:00:00">2025-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/07/09/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="MarkDown基础语法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://s21.ax1x.com/2025/07/09/pVQV3oF.md.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="MarkDown基础语法"/></a><div class="content"><a class="title" href="/2025/07/09/MarkDown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/" title="MarkDown基础语法">MarkDown基础语法</a><time datetime="2025-07-08T16:00:00.000Z" title="发表于 2025-07-09 00:00:00">2025-07-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="workboard"><img class="workSituationImg boardsign" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-上班摸鱼中.svg" alt="距离月入25k也就还差一个大佬带我~" title="距离月入25k也就还差一个大佬带我~"/><div id="runtimeTextTip"></div></div><div id="anzhiyu-footer"><div class="footer-group"><div class="footer-title">服务</div><div class="footer-links"><a class="footer-item" title="51la统计" target="_blank" rel="noopener" href="https://v6.51.la/">51la统计</a><a class="footer-item" title="十年之约" target="_blank" rel="noopener" href="https://www.foreverblog.cn/">十年之约</a><a class="footer-item" title="开往" target="_blank" rel="noopener" href="https://github.com/travellings-link/travellings">开往</a></div></div><div class="footer-group"><div class="footer-title">主题</div><div class="footer-links"><a class="footer-item" title="文档" href="/docs/">文档</a><a class="footer-item" title="源码" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu">源码</a><a class="footer-item" title="更新日志" href="/update/">更新日志</a></div></div><div class="footer-group"><div class="footer-title">导航</div><div class="footer-links"><a class="footer-item" title="即刻短文" href="/essay/">即刻短文</a><a class="footer-item" title="友链文章" href="/fcircle/">友链文章</a><a class="footer-item" title="留言板" href="/comments/">留言板</a></div></div><div class="footer-group"><div class="footer-title">协议</div><div class="footer-links"><a class="footer-item" title="隐私协议" href="/privacy/">隐私协议</a><a class="footer-item" title="Cookies" href="/cookies/">Cookies</a><a class="footer-item" title="版权协议" href="/copyright/">版权协议</a></div></div><div class="footer-group"><div class="footer-title-group"><div class="footer-title">友链</div><a class="random-friends-btn" id="footer-random-friends-btn" href="javascript:addFriendLinksInFooter();" title="换一批友情链接"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right"></i></a></div><div class="footer-links" id="friend-links-in-footer"></div></div></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v5.4.0" title="博客框架为Hexo_v5.4.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v5.4.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://www.dogecloud.com/" style="margin-inline:5px" data-title="本站使用多吉云为静态资源提供CDN加速" title="本站使用多吉云为静态资源提供CDN加速"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/CDN-多吉云-3693F3.svg" alt="本站使用多吉云为静态资源提供CDN加速"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2025 By <a class="footer-bar-link" href="/" title="Wizard小志" target="_blank">Wizard小志</a></div></div><div id="footer-type-tips"></div><div class="js-pjax"><script>function subtitleType () {
  getScript('https://sdk.jinrishici.com/v2/browser/jinrishici.js').then(() => {
    jinrishici.load(result =>{
      if (true) {
        const sub = []
        const content = result.data.content
        sub.unshift(content)
        window.typed = new Typed('#footer-type-tips', {
          strings: sub,
          startDelay: 1000,
          typeSpeed: 250,
          loop: true,
          backSpeed: 40,
        })
      } else {
        document.getElementById('footer-type-tips').innerHTML = result.data.content
      }
    })
  })
}

if (true) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.cbd.int/typed.js@2.1.0/dist/typed.umd.js').then(subtitleType)
  }
} else {
  subtitleType()
}
</script></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">2</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">2</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">简介</div><div class="back-menu-list"><a class="back-menu-item" href="https://yanruizhi.github.io/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">轻松一刻</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.jugege.cc/" title="看场电影"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="看场电影"/><span class="back-menu-item-text">看场电影</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://www.yikm.net/" title="小霸王"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://files.codelife.cc/website/5f4ca285aa121b0c2ac69ee8.png?x-oss-process=image/resize,limit_0,m_fill,w_100,h_100/quality,q_92/format,webp" alt="小霸王"/><span class="back-menu-item-text">小霸王</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">资料库</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://imgse.com/yanruizhi" title="图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="图床"/><span class="back-menu-item-text">图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/?id=495199691&amp;server=netease&amp;type=playlist"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 我的追番</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/cinemas/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 我的追剧</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/equipment/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 我的装备</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/MarkDown/" style="font-size: 0.88rem;">MarkDown<sup>1</sup></a><a href="/tags/%E9%9D%A2%E8%AF%95/" style="font-size: 0.88rem;">面试<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="anzhiyufont anzhiyu-icon-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="anzhiyufont anzhiyu-icon-xmark"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("07/01/2025 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2025 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Wizard小志 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><script async="async">(function () {
  var grt = new Date("07/01/2025 00:00:00"); //设置网站上线时间
  var now = new Date();
  var dnum;
  var hnum;
  var mnum;
  var snum;
  var nowHour;

  // 计算并更新天数、小时数、分钟数和秒数
  function updateTime() {
    now = new Date(); // 更新 now 的值
    nowHour = now.getHours(); // 更新 nowHour 的值
    var days = (now - grt) / 1000 / 60 / 60 / 24;
    dnum = Math.floor(days);
    var hours = (now - grt) / 1000 / 60 / 60 - 24 * dnum;
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
      hnum = "0" + hnum;
    }
    var minutes = (now - grt) / 1000 / 60 - 24 * 60 * dnum - 60 * hnum;
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
      mnum = "0" + mnum;
    }
    var seconds = (now - grt) / 1000 - 24 * 60 * 60 * dnum - 60 * 60 * hnum - 60 * mnum;
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
      snum = "0" + snum;
    }
  }

  // 更新网页中显示的网站运行时间
  function updateHtml() {
    const footer = document.getElementById("footer");
    if (!footer) return
    let currentTimeHtml = "";
    if (nowHour < 18 && nowHour >= 9) {
      // 如果是上班时间，默认就是"安知鱼-上班摸鱼中.svg"图片，不需要更改
      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    } else {
      // 如果是下班时间，插入"安知鱼-下班啦.svg"图片
      let img = document.querySelector("#workboard .workSituationImg");
      if (img != null) {
        img.src = "https://npm.elemecdn.com/anzhiyu-blog@2.0.4/img/badge/安知鱼-下班啦.svg";
        img.title = "下班了就该开开心心的玩耍，嘿嘿~";
        img.alt = "下班了就该开开心心的玩耍，嘿嘿~";
      }

      currentTimeHtml = `本站居然运行了 ${dnum} 天<span id='runtime'> ${hnum} 小时 ${mnum} 分 ${snum} 秒 </span><i class='anzhiyufont anzhiyu-icon-heartbeat' style='color:red'></i>`;
    }

    if (document.getElementById("runtimeTextTip")) {
      document.getElementById("runtimeTextTip").innerHTML = currentTimeHtml;
    }
  }

  setInterval(() => {
    updateTime();
    updateHtml();
  }, 1000);
})();</script><script src="https://cdn.cbd.int/algoliasearch@4.18.0/dist/algoliasearch-lite.umd.js"></script><script src="https://cdn.cbd.int/instantsearch.js@4.60.0/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo-rouge-seven.vercel.app/',
      region: '',
      onCommentLoaded: () => {
        anzhiyu.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') setTimeout(runFn,0)
    else getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runFn)
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo-rouge-seven.vercel.app/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const runFn = () => {
    init();
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) anzhiyu.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else {
      loadTwikoo()
    }
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script>window.addEventListener('load', () => {
  const changeContent = (content) => {
    if (content === '') return content

    content = content.replace(/<img.*?src="(.*?)"?[^\>]+>/ig, '[图片]') // replace image link
    content = content.replace(/<a[^>]+?href=["']?([^"']+)["']?[^>]*>([^<]+)<\/a>/gi, '[链接]') // replace url
    content = content.replace(/<pre><code>.*?<\/pre>/gi, '[代码]') // replace code
    content = content.replace(/<[^>]+>/g,"") // remove html tag

    if (content.length > 150) {
      content = content.substring(0,150) + '...'
    }
    return content
  }

  const getComment = () => {
    const runTwikoo = () => {
      twikoo.getRecentComments({
        envId: 'https://twikoo-rouge-seven.vercel.app/',
        region: '',
        pageSize: 6,
        includeReply: true
      }).then(function (res) {
        const twikooArray = res.map(e => {
          return {
            'content': changeContent(e.comment),
            'avatar': e.avatar,
            'nick': e.nick,
            'url': e.url + '#' + e.id,
            'date': new Date(e.created).toISOString()
          }
        })

        saveToLocal.set('twikoo-newest-comments', JSON.stringify(twikooArray), 10/(60*24))
        generateHtml(twikooArray)
      }).catch(function (err) {
        const $dom = document.querySelector('#card-newest-comments .aside-list')
        $dom.textContent= "无法获取评论，请确认相关配置是否正确"
      })
    }

    if (typeof twikoo === 'object') {
      runTwikoo()
    } else {
      getScript('https://cdn.cbd.int/twikoo@1.6.39/dist/twikoo.all.min.js').then(runTwikoo)
    }
  }

  const generateHtml = array => {
    let result = ''

    if (array.length) {
      for (let i = 0; i < array.length; i++) {
        result += '<div class=\'aside-list-item\'>'

        if (true) {
          const name = 'data-lazy-src'
          result += `<a href='${array[i].url}' class='thumbnail'><img ${name}='${array[i].avatar}' alt='${array[i].nick}'><div class='name'><span>${array[i].nick} </span></div></a>`
        }
        
        result += `<div class='content'>
        <a class='comment' href='${array[i].url}' title='${array[i].content}'>${array[i].content}</a>
        <time datetime="${array[i].date}">${anzhiyu.diffDate(array[i].date, true)}</time></div>
        </div>`
      }
    } else {
      result += '没有评论'
    }

    let $dom = document.querySelector('#card-newest-comments .aside-list')
    $dom && ($dom.innerHTML= result)
    window.lazyLoadInstance && window.lazyLoadInstance.update()
    window.pjax && window.pjax.refresh($dom)
  }

  const newestCommentInit = () => {
    if (document.querySelector('#card-newest-comments .aside-list')) {
      const data = saveToLocal.get('twikoo-newest-comments')
      if (data) {
        generateHtml(JSON.parse(data))
      } else {
        getComment()
      }
    }
  }

  newestCommentInit()
  document.addEventListener('pjax:complete', newestCommentInit)
})</script><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","meta[property=\"og:type\"]","meta[property=\"og:site_name\"]","meta[property=\"og:description\"]","head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>